grammar Ceylon;

%start      : compilationUnit ;
%whitespace : skip ;
%keywords   : LIDENTIFIER ;

compilationUnit
    : hash-tag?
      ( compilerAnnotations ';' )?
      ( importDeclaration | moduleDescriptor | packageDescriptor | toplevelDeclaration )*
    ;

toplevelDeclaration
    : compilerAnnotations declaration
    ;

moduleDescriptor
    : annotations
      'module' 
      packagePath (importNamespace ':' (literal-string | packagePath) (':' literal-string (':' literal-string)? )? )?
      literal-string?
      importModuleList
    ;

importModuleList
    : '{' ( annotations (inferredAttributeDeclaration | importModule) )* '}'
    ;

packageDescriptor
    : annotations 'package' packagePath ';'
    ;

importModule
    : 'import'
      (importNamespace ':')?
      (
        (literal-string | packagePath) ( ':' literal-string ( ':' literal-string )? )?
      )
      (literal-string | memberName)?
      ';'
    ;

importNamespace
    : LIDENTIFIER
    | UIDENTIFIER
    ;

importDeclaration
    : 'import' packagePath importElementList
    ;

importElementList
    : '{' ((importElement | importWildcard) (',' (importElement | importWildcard))*)? '}'
    ;

importElement
    : compilerAnnotations ( importName ('=' importName)? importElementList?)
    ;

importWildcard
    : '...'
    ;

importName
    : memberName
    | typeName
    ;

packagePath
    : packageName ( '.' packageName )*
    ;

packageName
    : LIDENTIFIER
    | UIDENTIFIER
    ;

typeName
    : UIDENTIFIER
    ;

annotationName
    : LIDENTIFIER
    ;

memberName
    : LIDENTIFIER
    ;
    
memberNameDeclaration
    : memberName
    ;

typeNameDeclaration
    : typeName
    ;

enumeratedObject
    : 'new' memberNameDeclaration? delegatedConstructor? block
    ;
    
objectDeclaration
    : 'object' memberNameDeclaration? extendedType? satisfiedTypes? classBody
    ;

objectExpression
    : 'object' extendedType? satisfiedTypes? classBody
    ;

voidOrInferredMethodDeclaration
    : ('void' | 'function') memberNameDeclaration? typeParameters? parameters* typeConstraints? (block | functionSpecifier? ';')
    ;

setterDeclaration
    : 'assign' memberNameDeclaration? (block | functionSpecifier? ';')
    ;

variableOrTuplePattern
    : tuplePattern
    | variablePattern
    ;

pattern
    : keyItemPattern
    | tuplePattern
    | variablePattern
    ;

tupleOrEntryPattern
    : keyItemPattern
    | tuplePattern
    ;

variablePattern
    : variable
    ;

tuplePattern
    : '[' (variadicPattern (',' variadicPattern)*)? ']'
    ;

variadicPattern
    : variadicVariable
    | pattern
    ;

variadicVariable
    : compilerAnnotations unionType? ('*' | '+') memberNameDeclaration?
    ;

keyItemPattern
    : variableOrTuplePattern '->' variableOrTuplePattern?
    ;

destructure
    : 'value' tupleOrEntryPattern specifier? ';'
    ;

destructure2
    : 'let' '(' letVariable (',' letVariable)* ')' ';'
    ;

inferredAttributeDeclaration
    : 'value' memberNameDeclaration?( (specifier | lazySpecifier)? ';' | block )
    ;

typedMethodOrAttributeDeclaration
    : (variadicType | 'dynamic') memberNameDeclaration
      ( typeParameters? parameters+ typeConstraints? (block | functionSpecifier? ';')
      | (specifier | lazySpecifier )? ';'
      | block
      )
    ;

interfaceDeclaration
    : ('interface' | 'dynamic')
      typeNameDeclaration?
      typeParameters?
      caseTypes?
      satisfiedTypes?
      typeConstraints?
      (interfaceBody | typeSpecifier? ';')
    ;

classDeclaration
    : 'class' 
      typeNameDeclaration?
      typeParameters?
      parameters?
      caseTypes?
      extendedType?
      satisfiedTypes?
      typeConstraints?
      (classBody | classSpecifier? ';')
    ;

constructor
    : 'new'
      memberNameDeclaration?
      parameters?
      delegatedConstructor?
      block
    ;

delegatedConstructor
    : 'extends' classInstantiation?
    ;

aliasDeclaration
    : 'alias'
      typeNameDeclaration?
      typeParameters?
      typeConstraints?
      typeSpecifier?
      ';'
    ;

assertion
    : assertMessage 'assert' conditions ';'
    ;

assertMessage
    : (stringLiteral | stringExpression)?
    ;


block
    : '{' (importDeclaration | declarationOrStatement)* '}'
    ;

//Note: interface bodies can't really contain 
//      statements, but error recovery works
//      much better if we validate that later
//      on, instead of doing it in the parser.
interfaceBody
    : '{' (importDeclaration | declarationOrStatement)* '}'
    ;

classBody
    : '{' (importDeclaration | declarationOrStatement)* '}'
    ;

extendedType
    : 'extends' classInstantiation?
    ;

classSpecifier
    : ('=>' | '=') classInstantiation?
    ;

packageQualifiedClass
    : 'package' ( '.' (typeNameWithArguments ( '.' memberNameWithArguments) ?) ? )?
   ;

unqualifiedClass
    : typeNameWithArguments ( '.' ( memberNameWithArguments | typeNameWithArguments ('.' typeNameWithArguments?)* )? )?
    | memberNameWithArguments
    ;

superQualifiedClass
    : 'super' '.' (typeNameWithArguments | memberNameWithArguments)?
    ;

classInstantiation
    : (packageQualifiedClass | unqualifiedClass | superQualifiedClass) (positionalArguments | namedArguments)?
    ;

satisfiedTypes
    : 'satisfies' primaryType (('&' | ',' | '|') primaryType)*
    ;

caseTypes
    : 'of' caseType ( '|' caseType )*
    ;

caseType
    : primaryType 
    | memberName
    | 'package' '.' memberName
    ;

abstractedType
    : 'abstracts' primaryType
    ;

parameters
    : '(' (parameterDeclarationOrRefOrPattern  (',' parameterDeclarationOrRefOrPattern)*)? ')'
    ;

parameterDeclarationOrRefOrPattern
    : tupleOrEntryPattern
    | parameterDeclarationOrRef
    ;

parameterDeclarationOrRef
    : parameter
    | parameterRef
    ;

parameter
    : annotations parameterDeclaration
    ;
    
parameterRef
    : memberName specifier?
    ;

parameterDeclaration
    : (variadicType | 'void' | 'function' | 'dynamic' | 'value')
      memberNameDeclaration
      (specifier? | typeParameters? parameters+ functionSpecifier?)
    ;

typeParameters
    : '<' typeParameter ( ',' typeParameter )* '>'
    ;

typeParameter
    : compilerAnnotations variance? typeNameDeclaration typeDefault?
    ;

variance
    : 'in'
    | 'out'
    ;
    
typeConstraint
    : compilerAnnotations 'given' typeNameDeclaration? typeParameters? caseTypes? satisfiedTypes? abstractedType?
    ;

anonymousTypeConstraint
    : 'given' typeNameDeclaration caseTypes? satisfiedTypes?
    ;

typeConstraints
    : typeConstraint+
    ;

anonymousTypeConstraints
    : anonymousTypeConstraint+
    ;

declarationOrStatement
    : compilerAnnotations
      ( destructure
      | destructure2
      | assertion
      | declaration
      | statement
      )
    ;

declaration
    : entityAnnotations
      ( classDeclaration
      | interfaceDeclaration
      | aliasDeclaration
      | objectDeclaration
      | setterDeclaration
      | voidOrInferredMethodDeclaration
      | inferredAttributeDeclaration
      | typedMethodOrAttributeDeclaration
      | constructor
      | enumeratedObject
      )
    ;

fullQualifiedType
    : baseType ('.' typeNameWithArguments)*
    ;

statement
    : directiveStatement
    | controlStatement
    | expressionOrSpecificationStatement
    ;

expressionOrSpecificationStatement
    : specificationStatement
    | expressionStatement
    ;

specificationStatement
    : valueExpression (specifier | lazySpecifier) ';'
    ;
    
expressionStatement
    : expression ';'
    ;

directiveStatement
    : directive ';'
    ;

directive
    : returnDirective
    | throwDirective
    | breakDirective
    | continueDirective
    ;

returnDirective
    : 'return' functionOrExpression
    | 'return'
    ;

throwDirective
    : 'throw' functionOrExpression
    | 'throw'
    ;

breakDirective
    : 'break'
    ;

continueDirective
    : 'continue'
    ;

typeSpecifier
    : ('=>' | '=') type?
    ;

typeDefault
    : '=' type
    ;

specifier
    : '=' functionOrExpression
    ;

lazySpecifier
    : '=>' functionOrExpression
    ;

functionSpecifier
    : ('=>' | '=') functionOrExpression
    ;

expression
    : assignmentExpression
    ;

base
    : nonstringLiteral
    | stringExpression
    | metaLiteral
    | enumeration
    | tuple
    | dynamicObject
    | objectExpression
    | parExpression
    | baseReferenceOrParameterized
    ;

baseReferenceOrParameterized
    : memberName typeParameters? parameters+
    | memberReference
    | typeReference
    | selfReference (memberSelectionOperator memberName typeParameters? parameters+)?
    ;

memberReference
    : memberName typeArguments
    | memberName
    ;

typeReference
    : typeName typeArguments
    | typeName
    ;

primary
    : primary qualifiedReference
    | primary indexOrIndexRange
    | primary positionalArguments
    | primary namedArguments
    | base
    ;

qualifiedReference
    : memberSelectionOperator (memberReference | typeReference)
    ;

memberSelectionOperator
    : '.'
    | '?.'
    | '*.'
    ;

indexOrIndexRange
    //TODO: move indexOperator to ElementOrRange and
    //      make this rule return ElementOrRange instead
    //      of IndexExpression, instantiating IndexExpression
    //      from the calling primary rule
    : '['
      ( '...' index
      | index ( '...' | '..' index | ':' index )?
      | functionOrExpression
      )
      ']'
    ;

enumeration
    : '{' declarationOrStatement* sequencedArgument? '}'
    ;

tuple
    : '[' sequencedArgument? ']'
    ;
    
dynamicObject
    : 'dynamic' (dynamicArguments | '[' ',' ']')
    ;

dynamicArguments
    : '[' (namedArgument | anonymousArgument)* sequencedArgument? ']'
    ;

valueCase
    : intersectionType 
    | intersectionExpression 
    ;

valueCaseList
    : valueCase ( (',' |'|') valueCase)*
    ;

index
    : additiveExpression 
    ;

namedArguments
    : '{' (namedArgument | anonymousArgument)* sequencedArgument? '}'
    ;

sequencedArgument
    : compilerAnnotations sequencedArgumentItem (',' sequencedArgumentItem)* 
    ;

sequencedArgumentItem
    : comprehension
    | positionalArgument
    | spreadArgument
    ;

namedArgument
    : compilerAnnotations (namedSpecifiedArgument | namedArgumentDeclaration)
    ;

namedSpecifiedArgument
    : memberName specifier? ';'
    ;

anonymousArgument
    : functionOrExpression ';'
    ;

objectArgument
    : 'object' memberNameDeclaration? extendedType? satisfiedTypes? classBody
    ;

voidOrInferredMethodArgument
    : ('void' | 'function') memberNameDeclaration? typeParameters? parameters* (block | functionSpecifier? ';')
    ;

inferredGetterArgument
    : 'value' memberNameDeclaration? (block | (specifier | lazySpecifier)? ';')
    ;

typedMethodOrGetterArgument
    : (type |'dynamic')
      memberNameDeclaration
      ( typeParameters? parameters+ (block | functionSpecifier? ';')
      | (block | (specifier | lazySpecifier)? ';')
      )
    ;

untypedMethodOrGetterArgument
    : memberName (parameters+ functionSpecifier | lazySpecifier ) ';'
    ;

namedArgumentDeclaration
    : objectArgument
    | typedMethodOrGetterArgument
    | voidOrInferredMethodArgument
    | inferredGetterArgument
    | untypedMethodOrGetterArgument
    ;

parExpression
    : '(' functionOrExpression ')'
    ;
        
positionalArguments
    : '(' sequencedArgument? ')'
    ;

positionalArgument
    : functionOrExpression
    ;

spreadArgument
    : '*' unionExpression
    ;

functionOrExpression
    : anonymousFunction
    | letClause
    | ifExpression
    | switchExpression
    | expression
    ;

letVariable
    : pattern specifier?
    ;

letVariable2
    : tupleOrEntryPattern specifier?
    ;

letClause
    : 'let' '(' (letVariable (',' letVariable)*)? ')' conditionalBranch
    ;

switchExpression
    : switchHeader
      caseExpressions
    ;

caseExpressions
    : caseExpression+ elseExpression?
    ;
    
caseExpression
    : 'else'? 'case' caseItemList conditionalBranch
    ;

elseExpression
    : 'else' conditionalBranch
    ;

ifExpression
    : 'if' conditions thenExpression elseExpression
    ;

conditionalBranch
    : ifExpression
    | letClause
    | disjunctionExpression
    ;

thenExpression
    : 'then' conditionalBranch
    ;

anonymousFunction
    : ('function' | 'void')? typeParameters? (parameters+ typeConstraints?)? ('=>' functionOrExpression | block)
    ;

comprehension
    : forComprehensionClause
    | ifComprehensionClause
    ;

comprehensionClause
    : forComprehensionClause 
    | ifComprehensionClause 
    | expressionComprehensionClause 
    ;

expressionComprehensionClause
    : functionOrExpression
    ;

forComprehensionClause
    : 'for' forIterator comprehensionClause
    ;
    
ifComprehensionClause
    : 'if' conditions comprehensionClause
    ;
    
assignmentExpression
    : thenElseExpression assignmentOperator functionOrExpression
    | thenElseExpression
    ;

assignmentOperator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '~='
    | '&&='
    | '||='
    ;

thenElseExpression
    : thenElseExpression thenElseOperator disjunctionExpression
    | disjunctionExpression
    ;

thenElseOperator
    : 'else' 
    | 'then'
    ;

disjunctionExpression
    : disjunctionExpression disjunctionOperator conjunctionExpression
    | conjunctionExpression
    ;

disjunctionOperator
    : '||' 
    ;

conjunctionExpression
    : conjunctionExpression conjunctionOperator logicalNegationExpression
    | logicalNegationExpression
    ;

conjunctionOperator
    : '&&' 
    ;

logicalNegationExpression
    : notOperator logicalNegationExpression
    | expressionOrMeta
    ;

notOperator
    : '!' 
    ;

expressionOrMeta
    : modelRef
    | equalityExpression
    ;

equalityExpression
    : comparisonExpression equalityOperator comparisonExpression
    | comparisonExpression
    ;

equalityOperator
    : '==' 
    | '!='
    | '==='
    ;

comparisonExpression
    : existenceEmptinessExpression comparisonOperator existenceEmptinessExpression
    | existenceEmptinessExpression largerOperator existenceEmptinessExpression
    | existenceEmptinessExpression smallerOperator existenceEmptinessExpression smallerOperator existenceEmptinessExpression
    | existenceEmptinessExpression smallerOperator existenceEmptinessExpression
    | existenceEmptinessExpression typeOperator type
    | existenceEmptinessExpression
    ;

smallerOperator
    : '<='
    | '<'
    ;

largerOperator
    : '>='
    | '>'
    ;

comparisonOperator
    : '<=>' 
    | 'in'
    ;

typeOperator
    : 'is'
    | 'extends'
    | 'satisfies'
    | 'of'
    ;

existenceEmptinessExpression
    : pipelinedExpression existsNonemptyOperator
    | pipelinedExpression
    ;

existsNonemptyOperator
    : 'exists' 
    | 'nonempty'
    ;

pipelinedExpression
    : pipelinedExpression pipelineOperator entryRangeExpression
    | entryRangeExpression
    ;

pipelineOperator
    : '|>'
    | '>|>'
    ;

entryRangeExpression
    : additiveExpression rangeIntervalEntryOperator additiveExpression
    | additiveExpression
    ;

rangeIntervalEntryOperator
    : '..' 
    | ':'
    | '->'
    ;

additiveExpression
    : additiveExpression additiveOperator scaleExpression
    | scaleExpression
    ;

additiveOperator
    : '+' 
    | '-'
    ;

scaleExpression
    : multiplicativeExpression scaleOperator scaleExpression
    | multiplicativeExpression
    ;

multiplicativeExpression
    : multiplicativeExpression multiplicativeOperator unionExpression
    | unionExpression
    ;

multiplicativeOperator
    : '*' 
    | '/'
    | '%'
    ;

unionExpression
    : unionExpression unionOperator intersectionExpression
    | intersectionExpression
    ;
    
unionOperator
    : '|'
    | '~'
    ;

intersectionExpression
    : intersectionExpression intersectionOperator negationComplementExpression
    | negationComplementExpression
    ;
    
intersectionOperator
    : '&'
    ;

negationComplementExpression
    : unaryMinusOrComplementOperator negationComplementExpression
    | exponentiationExpression
    ;

unaryMinusOrComplementOperator
    : '-' 
    | '+'
    | '~'
    ;

exponentiationExpression
    : incrementDecrementExpression exponentiationOperator exponentiationExpression
    | incrementDecrementExpression
    ;

exponentiationOperator
    : '^' 
    ;

scaleOperator
    : '**' 
    ;

incrementDecrementExpression
    : prefixOperator incrementDecrementExpression
    | postfixIncrementDecrementExpression
    ;

prefixOperator
    : '--'
    | '++'
    ;

postfixIncrementDecrementExpression
    : postfixIncrementDecrementExpression postfixOperator
    | valueExpression
    ;

valueExpression
    : declarationRef
    | primary
    ;

postfixOperator
    : '--' 
    | '++' 
    ;

selfReference
    : 'this'
    | 'super' 
    | 'outer'
    | 'package'
    ;
    
nonstringLiteral
    : literal-natural 
    | literal-float 
    | literal-char 
    ;

stringLiteral
    : literal-string 
    | verbatim-string
    ;

stringExpression
    : stringLiteral
    | STRING_START functionOrExpression (STRING_MID functionOrExpression)* STRING_END
    ;

typeArguments
    : '<' ( ( variance type? | type) (',' (variance type | type) )* )? '>'
    ;

defaultedType
    : type '='
    | variadicType
    ;

variadicType
    : unionType ('*' | '+')
    | type
    ;

spreadType
    : '*' unionType?
    ;

tupleType
    : '[' (spreadType | defaultedType (',' defaultedType )*)? ']'
    ;

groupedType
    : '<' type '>'
    ;

iterableType
   : '{' variadicType? '}'
   ;

type
    : typeParameters anonymousTypeConstraints? '=>' entryType
    | entryType
    ;

entryType
    : unionType '->' unionType
    | unionType
    ;

unionType
    : unionType '|' intersectionType
    | intersectionType
    ;

intersectionType
    : intersectionType '&' primaryType
    | primaryType
    ;


primaryType
    : primaryType '?'
    | primaryType '[' literal-natural? ']'
    | primaryType '(' ( spreadType | defaultedType (',' defaultedType)* )? ')'
    | atomicType
    ;

primaryTypeX
    : atomicType
      ( '?' 
      | '[' literal-natural? ']' 
      | '(' ( spreadType | defaultedType (',' defaultedType)* )? ')'
      )*
    ;

atomicType
    : qualifiedType 
    | tupleType 
    | iterableType
    ;

baseType
    : typeNameWithArguments
    | groupedType
    | 'package' '.' typeNameWithArguments
    ;

qualifiedType
    : qualifiedType '.' typeNameWithArguments
    | baseType
    ;

typeNameWithArguments
    : typeName typeArguments
    | typeName
    ;
    
memberNameWithArguments
    : memberName typeArguments
    | memberName
    ;
    
entityAnnotations
    : stringLiteral? entityAnnotation*
    ;

entityAnnotation
    : annotationName ( positionalArguments | namedArguments )?
    ;

compilerAnnotations
    : compilerAnnotation*
    ;
    
compilerAnnotation
    : ('$' | '@' | '#') annotationName (':' stringLiteral)?
    ;

conditions
    : '(' ( condition ( ',' condition )* )? ')'
    ;

annotations
    : compilerAnnotations entityAnnotations
    ;

condition
    : existsCondition
    | nonemptyCondition
    | isCondition 
    | satisfiesCondition
    | booleanCondition
    ;
    
booleanCondition
    : functionOrExpression
    ;


existsCondition
    : '!'? 'exists' (letVariable2 | impliedVariable | expression)
    ;
    
nonemptyCondition
    : '!'? 'nonempty' (letVariable2 | impliedVariable | expression)
    ;

isCondition
    : '!'? 'is' type (isConditionVariable | impliedVariable)
    ;

isConditionVariable
    : memberNameDeclaration specifier
    ;

satisfiesCondition
    : 'satisfies' type typeName
    ;

controlStatement
    : ifElse 
    | switchCaseElse 
    | whileLoop 
    | forElse 
    | tryCatchFinally
    | dynamic
    ;

controlBlock
    : block
    ;

dynamic
    : dynamicClause
    ;
    
dynamicClause
    : 'dynamic' block
    ;

ifElse
    : ifBlock elseBlock?
    ;

ifBlock
    : 'if' conditions controlBlock
    ;

elseBlock
    : 'else' (elseIf | block)
    ;

elseIf
    : ifElse
    ;

switchCaseElse
    : switchHeader 
      cases
    ;

switchHeader
    : 'switch' '(' switched? ')'
    ;

compilerAnnotationStart
    : '$' | '@'
    ;

switched
    : (specifiedVariable | expression)
    ;

cases
    : caseBlock+ elseBlock?
    ;
    
caseBlock
    : 'else'? 'case' caseItemList block
    ;

caseItemList
    : '(' caseItem? ')' 
    ;

caseItem
    : isCaseCondition 
    | satisfiesCaseCondition
    | matchCaseCondition
    | pattern
    ;

matchCaseCondition
    : valueCaseList
    ;

isCaseCondition
    : 'is'? type '.'?
    ;

satisfiesCaseCondition
    : 'satisfies' type
    ;

forElse
    : forBlock failBlock?
    ;

forBlock
    : 'for' forIterator controlBlock
    ;

failBlock
    : 'else' controlBlock
    ;

forIterator
    : '(' ( (tupleOrEntryPattern | variable) containment? )? ')'
    ;
    
containment
    : ('in' | ':') expression?
    ;
    
whileLoop
    : whileBlock
    ;

whileBlock
    : 'while' conditions controlBlock
    ;

tryCatchFinally
    : tryBlock catchBlock* finallyBlock?
    ;

tryBlock
    : 'try' (resources controlBlock | block)
    ;

catchBlock
    : 'catch' catchVariable controlBlock
    ;

catchVariable
    : '(' variable? ')' 
    ;


finallyBlock
    : 'finally' controlBlock
    ;

resources
    : '(' ( resource (',' resource)* )? ')'
    ;

resource
    : specifiedVariable
    | expression
    ;

specifiedVariable
    : variable specifier?
    ;

variable
    : compilerAnnotations var
    ;
    
var
    : (type | 'void' | 'function' | 'value') memberNameDeclaration parameters*
    | memberName parameters*
    ;

impliedVariable
    : memberName 
    ;

referencePathElement
    : typeName 
    | memberName
    ;
    
referencePath
    : ( referencePathElement | 'package' '.' referencePathElement ) ('.' referencePathElement)*
    ; 

moduleLiteral
 : 'module' packagePath?
 ;

packageLiteral
 : 'package' packagePath?
 ;

classLiteral
 : 'class' referencePath?
 ;

interfaceLiteral
 : 'interface' referencePath?
 ;

aliasLiteral
 : 'alias' referencePath?
 ;

typeParameterLiteral
 : 'given' referencePath?
 ;

newLiteral
 : 'new' referencePath?
 ;

valueLiteral
  : ('value' | 'object') referencePath
  ;

functionLiteral
  : 'function' referencePath
  ;

memberPathElement
    : memberName typeArguments?
    ;
    

memberModelExpression
    : memberPathElement 
    | 'package' '.' memberPathElement
    | primaryType '.' memberPathElement
    ; 

typeModelExpression
    : type
    ;

modelExpression
  : memberModelExpression
  | typeModelExpression
  ;

metaLiteral
    : '`' (declarationRef | modelExpression) '`'
    ;

modelRef
    : '^' modelExpression
    ;
    
declarationRef
    : moduleLiteral
    | packageLiteral
    | classLiteral
    | newLiteral
    | interfaceLiteral
    | aliasLiteral
    | typeParameterLiteral
    | valueLiteral
    | functionLiteral
    ;


// Lexer

Digits
    : Digit ('_' | Digit)*
    ;

HexDigits
    : HexDigit ('_' | HexDigit)*
    ;

BinaryDigits
    : BinaryDigit ('_' | BinaryDigit)*
    ;

Exponent
    : ( 'e' | 'E' ) ( '+' | '-' )? Digit*
    ;

Magnitude
    : 'k' | 'M' | 'G' | 'T' | 'P'
    ;

FractionalMagnitude
    : 'm' | 'u' | 'n' | 'p' | 'f'
    ;
    
literal-float
    : < Digits ( '.' Digits (Exponent|Magnitude|FractionalMagnitude)? | FractionalMagnitude) >
    ;

literal-natural
    : < Digits Magnitude? | '#' HexDigits | '$' BinaryDigits >
    ;

literal-char
    : < '\'' char-part '\'' >
    ;

STRING_START
    : < '"' string-part '``' >
    ;

STRING_MID
    : < '``' string-part '``' >
    ;

STRING_END
    : < '``' string-part '`'* '"' >
    ;

literal-string
    : < '"' string-part '`'* '"' >
    ;

verbatim-string
    : < '"""' (~'"' | '"' ~'"' | '""' ~'"')* ('"' ('"' ('"' ('"' '"'?)?)?)?)? >
    ;

char-part
    : ( ~('\\' | '\'') | escape-sequence )*
    ;

string-part
    : ( ~('\\'| '"'|'`') | ('`' ~('`'|'"'|'\\')) | '`\\' escape-core | escape-sequence )*
    ;

escape-sequence
    : '\\' (~'{' | '{' (~'}')* '}' )
    ;

escape-core
    : ~'{'
    | '{' (~'}')* '}'?
    ;

skip
    : white
    | comment
    ;

white
    : ( ' ' | '\r' | '\t' | '\f' | '\n' )+
    ;

line-end
    : '\r' '\n'
    | '\n'
    | '\r'
    ;

line-ender
    : '\r'
    | '\n'
    ;

comment
    : line-comment
    | block-comment
    ;

hash-tag
    : < '#!' (~line-ender)* line-end? >
    ;

line-comment
    :   '//' (~line-ender)* line-end?
    ;   

block-comment
    : '/*' ( ~'*' | '*'+ ~('*'|'/') )* '*'+ '/'
    ;

/*
    List of keywords.
*/

LIDENTIFIER
    : < LStart IdentifierPart* | LIdentifierPrefix IdentifierPart+ >
    ;

UIDENTIFIER 
    : < UStart IdentifierPart* | UIdentifierPrefix IdentifierPart+ >
    ;

IdentifierStart
    :   '_'
    |   Letter
    ;

LStart
    : '_'
    | 'a' .. 'z'
    ;

UStart
    : 'A' .. 'Z'
    ;

LIdentifierPrefix
    : '\\i'
    ;

UIdentifierPrefix
    : '\\I'
    ;
    
IdentifierPart
    :   '_'
    |   Digit
    |   Letter
    ;

Letter
    : 'a'..'z' 
    | 'A'..'Z' 
    | '\u{0080}'..'\u{ffff}'
    ;

Digit
    : '0'..'9'
    ;

HexDigit
    : '0'..'9' | 'A'..'F' | 'a'..'f'
    ;

BinaryDigit
    : '0'|'1'
    ;
