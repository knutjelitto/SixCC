grammar Ceylon;

%start      : compilation-unit ;
%whitespace : skip ;
%keywords   : LIDENTIFIER ;

compilation-unit
    : hash-tag? ( compilerAnnotations ';' )? unit-elements
    ;

unit-elements
    : unit-element*
    ;

unit-element
    : module-descriptor
    | package-descriptor
    | import-declaration
    | declaration
    ;

module-descriptor
    : annotations 'module' module-name
      (import-namespace ':' (literalString | module-name) (':' literalString (':' literalString)? )? )?
      literalString?
      module-body
    ;

module-name
    : package-path
    ;

module-body
    : '{' ( annotations (inferredAttributeDeclaration | import-module) )* '}'
    ;

package-descriptor
    : annotations 'package' package-path ';'
    ;

import-module
    : 'import' (import-namespace ':')? (literalString | package-path) ( ':' literalString ( ':' literalString )? )? (literalString | member-name)? ';'
    ;

import-namespace
    : LIDENTIFIER
    | UIDENTIFIER
    ;

import-declaration
    : 'import' package-path import-element-list
    ;

import-element-list
    : '{' ((import-element | import-wildcard) (',' (import-element | import-wildcard))*)? '}'
    ;

import-element
    : compilerAnnotations ( import-name ('=' import-name)? import-element-list?)
    ;

import-wildcard
    : '...'
    ;

import-name
    : member-name
    | type-name
    ;

package-path
    : package-name ( '.' package-name )*
    ;

any-name
    : LIDENTIFIER
    | UIDENTIFIER
    ;

package-name
    : any-name
    ;

annotation-name
    : LIDENTIFIER
    ;

member-name
    : LIDENTIFIER
    ;
    
type-name
    : UIDENTIFIER
    ;

member-name-declaration
    : member-name
    ;

type-name-declaration
    : type-name
    ;

enumerated-object
    : 'new' member-name-declaration? delegated-constructor? block
    ;
    
object-declaration
    : 'object' member-name-declaration? extended-type? satisfied-types? class-body
    ;

object-expression
    : 'object' extended-type? satisfied-types? class-body
    ;

voidOrInferredMethodDeclaration
    : voidOrFunction member-name-declaration? type-parameters? parameters* type-constraints? (block | functionSpecifier? ';')
    ;

setter-declaration
    : 'assign' member-name-declaration (block | functionSpecifier ';')
    ;

variableOrTuplePattern
    : tuple-pattern
    | variable-pattern
    ;

pattern
    : entry-pattern
    | tuple-pattern
    | variable-pattern
    ;

tupleOrEntryPattern
    : entry-pattern
    | tuple-pattern
    ;

entry-pattern
    : variableOrTuplePattern '->' variableOrTuplePattern
    ;

tuple-pattern
    : '[' (variadicPattern (',' variadicPattern)*)? ']'
    ;

variable-pattern
    : variable
    ;

variadicPattern
    : variadic-variable
    | pattern
    ;

variadic-variable
    : compilerAnnotations unionType? ('*' | '+') member-name-declaration?
    ;

//destructure
//    : 'value' tupleOrEntryPattern specifier ';'
//    ;

destructure
    : 'let' '(' letVariable (',' letVariable)* ')' ';'
    ;

inferredAttributeDeclaration
    : 'value' member-name-declaration (block | functionSpecifier? ';')
    ;

typedMethodOrAttributeDeclaration
    : (variadicType | 'dynamic') member-name-declaration
      ( type-parameters? parameters+ type-constraints? (block | functionSpecifier? ';')
      | (specifier | lazySpecifier )? ';'
      | block
      )
    ;

interface-declaration
    : ('interface' | 'dynamic')
      type-name-declaration
      type-parameters?
      case-types?
      satisfied-types?
      type-constraints?
      (interface-body | type-specifier? ';')
    ;

class-declaration
    : 'class' 
      type-name-declaration
      type-parameters?
      parameters?
      case-types?
      extended-type?
      satisfied-types?
      type-constraints?
      (class-body | class-specifier? ';')
    ;

constructor
    : 'new' member-name-declaration? parameters? delegated-constructor? block
    ;

delegated-constructor
    : 'extends' classInstantiation
    ;

alias-declaration
    : 'alias' type-name-declaration type-parameters? type-constraints? type-specifier? ';'
    ;

assertion
    : assertion-message 'assert' conditions ';'
    ;

assertion-message
    : stringExpression?
    ;

block
    : '{' (import-declaration | declaration-or-statement)* '}'
    ;

interface-body
    : '{' (import-declaration | declaration-or-statement)* '}'
    ;

class-body
    : '{' (import-declaration | declaration-or-statement)* '}'
    ;

extended-type
    : 'extends' classInstantiation
    ;

class-specifier
    : ('=>' | '=') classInstantiation
    ;

classInstantiation
    : (package-qualified-class | super-qualified-class | un-qualified-class) (positional-arguments | namedArguments)?
    ;

super-qualified-class
    : super-qualifier (typeNameWithArguments | memberNameWithArguments)
    ;

super-qualifier
    : 'super' '.'
    ;

package-qualified-class
    : package-qualifier typeNameWithArguments ( '.' memberNameWithArguments)?
    ;

package-qualifier
    : 'package' '.'
    ;

un-qualified-class
    : typeNameWithArguments ( '.' ( memberNameWithArguments | typeNameWithArguments ('.' typeNameWithArguments?)* )? )?
    | memberNameWithArguments
    ;

satisfied-types
    : 'satisfies' primaryType ( ('&' | ',' | '|') primaryType )*
    ;

case-types
    : 'of' caseType ( '|' caseType )*
    ;

caseType
    : primaryType 
    | member-name
    | package-qualifier member-name
    ;

parameters
    : '(' (parameterDeclarationOrRefOrPattern  (',' parameterDeclarationOrRefOrPattern)*)? ')'
    ;

parameterDeclarationOrRefOrPattern
    : tupleOrEntryPattern
    | parameterDeclarationOrRef
    ;

parameterDeclarationOrRef
    : parameter
    | parameterRef
    ;

parameter
    : annotations parameterDeclaration
    ;
    
parameterRef
    : member-name specifier?
    ;

parameterDeclaration
    : (variadicType | 'void' | 'function' | 'dynamic' | 'value')
      member-name-declaration
      (specifier? | type-parameters? parameters+ functionSpecifier?)
    ;

type-parameters
    : '<' typeParameter ( ',' typeParameter )* '>'
    ;

typeParameter
    : compilerAnnotations variance? type-name-declaration typeDefault?
    ;

variance
    : 'in'
    | 'out'
    ;
    
typeConstraint
    : compilerAnnotations 'given' type-name-declaration? type-parameters? case-types? satisfied-types?
    ;

type-constraints
    : typeConstraint+
    ;

declaration-or-statement
    : declaration
    | compilerAnnotations (destructure | assertion | statement)
    ;

declaration
    : annotations
      ( class-declaration
      | interface-declaration
      | alias-declaration
      | object-declaration
      | setter-declaration
      | voidOrInferredMethodDeclaration
      | inferredAttributeDeclaration
      | typedMethodOrAttributeDeclaration
      | constructor
      | enumerated-object
      )
    ;

fullQualifiedType
    : baseType ('.' typeNameWithArguments)*
    ;

statement
    : directiveStatement
    | controlStatement
    | expressionOrSpecificationStatement
    ;

expressionOrSpecificationStatement
    : expressionStatement
    | specificationStatement
    ;

specificationStatement
    : valueExpression (specifier | lazySpecifier) ';'
    ;
    
expressionStatement
    : expression ';'
    ;

directiveStatement
    : directive ';'
    ;

directive
    : returnDirective
    | throwDirective
    | breakDirective
    | continueDirective
    ;

returnDirective
    : 'return' function-or-expression
    | 'return'
    ;

throwDirective
    : 'throw' function-or-expression
    | 'throw'
    ;

breakDirective
    : 'break'
    ;

continueDirective
    : 'continue'
    ;

type-specifier
    : ('=>' | '=') type?
    ;

typeDefault
    : '=' type
    ;

specifier
    : '=' function-or-expression
    ;

lazySpecifier
    : '=>' function-or-expression
    ;

functionSpecifier
    : specifier
    | lazySpecifier
    ;

expression
    : assignmentExpression
    ;

base
    : nonstringLiteral
    | stringExpression
    | metaLiteral
    | enumeration
    | tuple
//    | dynamicObject
    | object-expression
    | grouped-expression
    | baseReferenceOrParameterized
    ;

baseReferenceOrParameterized
    : member-name type-parameters? parameters+
    | memberReference
    | typeReference
    | selfReference (memberSelectionOperator member-name type-parameters? parameters+)?
    ;

memberReference
    : member-name type-arguments?
    ;

typeReference
    : type-name type-arguments?
    ;

primary
    : primary qualifiedReference
    | primary indexOrIndexRange
    | primary positional-arguments
    | primary namedArguments
    | base
    ;

qualifiedReference
    : memberSelectionOperator (memberReference | typeReference)
    ;

selfReference
    : 'this'
    | 'super' 
    | 'outer'
    | 'package'
    ;
    
memberSelectionOperator
    : '.'
    | '?.'
    | '*.'
    ;

indexOrIndexRange
    //TODO: move indexOperator to ElementOrRange and
    //      make this rule return ElementOrRange instead
    //      of IndexExpression, instantiating IndexExpression
    //      from the calling primary rule
    : '['
      ( '...' index
      | index ( '...' | '..' index | ':' index )?
      | function-or-expression
      )
      ']'
    ;

enumeration
    : '{' declaration-or-statement* sequencedArgument? '}'
    ;

tuple
    : '[' sequencedArgument? ']'
    ;
    
//dynamicObject
//    : 'dynamic' (dynamicArguments | '[' ',' ']')
//    ;
//
//dynamicArguments
//    : '[' (namedArgument | anonymousArgument)* sequencedArgument? ']'
//    ;

valueCase
    : intersectionType 
    | intersectionExpression 
    ;

valueCaseList
    : valueCase ( (',' |'|') valueCase)*
    ;

index
    : additiveExpression 
    ;

namedArguments
    : '{' (namedArgument | anonymousArgument)* sequencedArgument? '}'
    ;

sequencedArgument
    : compilerAnnotations sequencedArgumentItem (',' sequencedArgumentItem)* 
    ;

sequencedArgumentItem
    : comprehension
    | positionalArgument
    | spreadArgument
    ;

namedArgument
    : compilerAnnotations (namedSpecifiedArgument | named-argument-declaration)
    ;

namedSpecifiedArgument
    : member-name specifier? ';'
    ;

anonymousArgument
    : function-or-expression ';'
    ;

object-argument
    : 'object' member-name-declaration? extended-type? satisfied-types? class-body
    ;

voidOrInferredMethodArgument
    : voidOrFunction member-name-declaration? type-parameters? parameters* (block | functionSpecifier? ';')
    ;

inferredGetterArgument
    : 'value' member-name-declaration (block | functionSpecifier? ';')
    ;

typedMethodOrGetterArgument
    : (type |'dynamic')
      member-name-declaration
      ( type-parameters? parameters+ (block | functionSpecifier? ';')
      | (block | (specifier | lazySpecifier)? ';')
      )
    ;

untypedMethodOrGetterArgument
    : member-name (parameters+ functionSpecifier | lazySpecifier ) ';'
    ;

named-argument-declaration
    : object-argument
    | typedMethodOrGetterArgument
    | voidOrInferredMethodArgument
    | inferredGetterArgument
    | untypedMethodOrGetterArgument
    ;

grouped-expression
    : '(' function-or-expression ')'
    ;
        
positional-arguments
    : '(' sequencedArgument? ')'
    ;

positionalArgument
    : function-or-expression
    ;

spreadArgument
    : '*' unionExpression
    ;

function-or-expression
    : anonymousFunction
    | letClause
    | ifExpression
    | switchExpression
    | expression
    ;

letVariable
    : pattern specifier?
    ;

letClause
    : 'let' '(' (letVariable (',' letVariable)*)? ')' conditionalBranch
    ;

switchExpression
    : switchHeader
      caseExpressions
    ;

caseExpressions
    : caseExpression+ elseExpression?
    ;
    
caseExpression
    : 'else'? 'case' caseItemList conditionalBranch
    ;

elseExpression
    : 'else' conditionalBranch
    ;

ifExpression
    : 'if' conditions thenExpression elseExpression
    ;

conditionalBranch
    : ifExpression
    | letClause
    | disjunctionExpression
    ;

thenExpression
    : 'then' conditionalBranch
    ;

anonymousFunction
    : voidOrFunction? type-parameters? (parameters+ type-constraints?)? ('=>' function-or-expression | block)
    ;

voidOrFunction
    : 'void'
    | 'function'
    ;

comprehension
    : forComprehensionClause
    | ifComprehensionClause
    ;

comprehensionClause
    : forComprehensionClause 
    | ifComprehensionClause 
    | expressionComprehensionClause 
    ;

expressionComprehensionClause
    : function-or-expression
    ;

forComprehensionClause
    : 'for' forIterator comprehensionClause
    ;
    
ifComprehensionClause
    : 'if' conditions comprehensionClause
    ;
    
assignmentExpression
    : thenElseExpression assignmentOperator function-or-expression
    | thenElseExpression
    ;

assignmentOperator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '~='
    | '&&='
    | '||='
    ;

thenElseExpression
    : thenElseExpression thenElseOperator disjunctionExpression
    | disjunctionExpression
    ;

thenElseOperator
    : 'else' 
    | 'then'
    ;

disjunctionExpression
    : disjunctionExpression disjunctionOperator conjunctionExpression
    | conjunctionExpression
    ;

disjunctionOperator
    : '||' 
    ;

conjunctionExpression
    : conjunctionExpression conjunctionOperator logicalNegationExpression
    | logicalNegationExpression
    ;

conjunctionOperator
    : '&&' 
    ;

logicalNegationExpression
    : notOperator logicalNegationExpression
    | expressionOrMeta
    ;

notOperator
    : '!' 
    ;

expressionOrMeta
    : modelRef
    | equalityExpression
    ;

equalityExpression
    : comparisonExpression equalityOperator comparisonExpression
    | comparisonExpression
    ;

equalityOperator
    : '==' 
    | '!='
    | '==='
    ;

comparisonExpression
    : existenceEmptinessExpression comparisonOperator existenceEmptinessExpression
    | existenceEmptinessExpression largerOperator existenceEmptinessExpression
    | existenceEmptinessExpression smallerOperator existenceEmptinessExpression smallerOperator existenceEmptinessExpression
    | existenceEmptinessExpression smallerOperator existenceEmptinessExpression
    | existenceEmptinessExpression typeOperator type
    | existenceEmptinessExpression
    ;

smallerOperator
    : '<='
    | '<'
    ;

largerOperator
    : '>='
    | '>'
    ;

comparisonOperator
    : '<=>' 
    | 'in'
    ;

typeOperator
    : 'is'
    | 'extends'
    | 'satisfies'
    | 'of'
    ;

existenceEmptinessExpression
    : entryRangeExpression existsNonemptyOperator
    | entryRangeExpression
    ;

existsNonemptyOperator
    : 'exists' 
    | 'nonempty'
    ;

entryRangeExpression
    : additiveExpression rangeIntervalEntryOperator additiveExpression
    | additiveExpression
    ;

rangeIntervalEntryOperator
    : '..' 
    | ':'
    | '->'
    ;

additiveExpression
    : additiveExpression additiveOperator scaleExpression
    | scaleExpression
    ;

additiveOperator
    : '+' 
    | '-'
    ;

scaleExpression
    : multiplicativeExpression scaleOperator scaleExpression
    | multiplicativeExpression
    ;

scaleOperator
    : '**' 
    ;

multiplicativeExpression
    : multiplicativeExpression multiplicativeOperator unionExpression
    | unionExpression
    ;

multiplicativeOperator
    : '*' 
    | '/'
    | '%'
    ;

unionExpression
    : unionExpression unionOperator intersectionExpression
    | intersectionExpression
    ;
    
unionOperator
    : '|'
    | '~'
    ;

intersectionExpression
    : intersectionExpression intersectionOperator negationComplementExpression
    | negationComplementExpression
    ;
    
intersectionOperator
    : '&'
    ;

negationComplementExpression
    : unaryMinusOrComplementOperator negationComplementExpression
    | exponentiationExpression
    ;

unaryMinusOrComplementOperator
    : '-' !'-'
    | '+' !'+'
    | '~'
    ;

exponentiationExpression
    : incrementDecrementExpression exponentiationOperator exponentiationExpression
    | incrementDecrementExpression
    ;

exponentiationOperator
    : '^' 
    ;

incrementDecrementExpression
    : prefixOperator incrementDecrementExpression
    | postfixIncrementDecrementExpression
    ;

prefixOperator
    : '--'
    | '++'
    ;

postfixIncrementDecrementExpression
    : postfixIncrementDecrementExpression postfixOperator
    | valueExpression
    ;

valueExpression
    : declaration-ref
    | primary
    ;

postfixOperator
    : '--' 
    | '++' 
    ;

nonstringLiteral
    : literalNatural 
    | literalFloat 
    | literalChar 
    ;

stringLiteral
    : literalString 
    | verbatimString
    ;

stringExpression
    : stringLiteral
    | stringStart function-or-expression (stringMid function-or-expression)* stringEnd
    ;

type-arguments
    : '<' ( ( variance type? | type) (',' (variance type | type) )* )? '>'
    ;

defaultedType
    : type '='
    | variadicType
    ;

variadicType
    : unionType ('*' | '+')
    | type
    ;

spreadType
    : '*' unionType?
    ;

tupleType
    : '[' (spreadType | defaultedType (',' defaultedType )*)? ']'
    ;

groupedType
    : '<' type '>'
    ;

iterableType
   : '{' variadicType? '}'
   ;

type
    : type-parameters '=>' entryType
    | entryType
    ;

entryType
    : unionType '->' unionType
    | unionType
    ;

unionType
    : unionType '|' intersectionType
    | intersectionType
    ;

intersectionType
    : intersectionType '&' primaryType
    | primaryType
    ;


primaryType
    : primaryType '?'
    | primaryType '[' literalNatural? ']'
    | primaryType '(' ( spreadType | defaultedType (',' defaultedType)* )? ')'
    | atomicType
    ;

atomicType
    : qualifiedType 
    | tupleType 
    | iterableType
    ;

baseType
    : typeNameWithArguments
    | groupedType
    | package-qualifier typeNameWithArguments
    ;

qualifiedType
    : qualifiedType '.' typeNameWithArguments
    | baseType
    ;

typeNameWithArguments
    : type-name type-arguments?
    ;
    
memberNameWithArguments
    : member-name type-arguments?
    ;
    
annotations
    : compilerAnnotations entityAnnotations
    ;

compilerAnnotations
    : compilerAnnotation*
    ;
    
compilerAnnotation
    : ('$' | '@' | '#') annotation-name (':' stringLiteral)?
    ;

entityAnnotations
    : stringLiteral? entityAnnotation*
    ;

entityAnnotation
    : annotation-name ( positional-arguments | namedArguments )?
    ;

conditions
    : '(' ( condition ( ',' condition )* )? ')'
    ;

condition
    : existsCondition
    | nonemptyCondition
    | isCondition 
    | satisfiesCondition
    | booleanCondition
    ;
    
existsCondition
    : '!'? 'exists' (letVariable | impliedVariable | expression)
    ;
    
nonemptyCondition
    : '!'? 'nonempty' (letVariable | impliedVariable | expression)
    ;

isCondition
    : '!'? 'is' type (isConditionVariable | impliedVariable)
    ;

isConditionVariable
    : member-name-declaration specifier
    ;

satisfiesCondition
    : 'satisfies' type type-name
    ;

booleanCondition
    : function-or-expression
    ;

controlStatement
    : ifElse 
    | switchCaseElse 
    | whileLoop 
    | forElse 
    | tryCatchFinally
    | dynamic
    ;

controlBlock
    : block
    ;

dynamic
    : dynamicClause
    ;
    
dynamicClause
    : 'dynamic' block
    ;

ifElse
    : ifBlock elseBlock?
    ;

ifBlock
    : 'if' conditions controlBlock
    ;

elseBlock
    : 'else' (elseIf | block)
    ;

elseIf
    : ifElse
    ;

switchCaseElse
    : switchHeader 
      cases
    ;

switchHeader
    : 'switch' '(' switched? ')'
    ;

compilerAnnotationStart
    : '$' | '@'
    ;

switched
    : (specifiedVariable | expression)
    ;

cases
    : caseBlock+ elseBlock?
    ;
    
caseBlock
    : 'else'? 'case' caseItemList block
    ;

caseItemList
    : '(' caseItem? ')' 
    ;

caseItem
    : isCaseCondition 
    | satisfiesCaseCondition
    | matchCaseCondition
    | pattern
    ;

matchCaseCondition
    : valueCaseList
    ;

isCaseCondition
    : 'is'? type '.'?
    ;

satisfiesCaseCondition
    : 'satisfies' type
    ;

forElse
    : forBlock failBlock?
    ;

forBlock
    : 'for' forIterator controlBlock
    ;

failBlock
    : 'else' controlBlock
    ;

forIterator
    : '(' ( (tupleOrEntryPattern | variable) containment? )? ')'
    ;
    
containment
    : ('in' | ':') expression?
    ;
    
whileLoop
    : whileBlock
    ;

whileBlock
    : 'while' conditions controlBlock
    ;

tryCatchFinally
    : tryBlock catchBlock* finallyBlock?
    ;

tryBlock
    : 'try' (resources controlBlock | block)
    ;

catchBlock
    : 'catch' catchVariable controlBlock
    ;

catchVariable
    : '(' variable? ')' 
    ;

finallyBlock
    : 'finally' controlBlock
    ;

resources
    : '(' ( resource (',' resource)* )? ')'
    ;

resource
    : specifiedVariable
    | expression
    ;

specifiedVariable
    : variable specifier?
    ;

variable
    : compilerAnnotations var
    ;
    
var
    : (type | 'void' | 'function' | 'value') member-name-declaration parameters*
    | member-name parameters*
    ;

impliedVariable
    : member-name 
    ;

referencePathElement
    : type-name 
    | member-name
    ;
    
referencePath
    : ( referencePathElement | package-qualifier referencePathElement ) ('.' referencePathElement)*
    ; 

moduleLiteral
 : 'module' package-path?
 ;

packageLiteral
 : 'package' package-path?
 ;

classLiteral
 : 'class' referencePath?
 ;

interfaceLiteral
 : 'interface' referencePath?
 ;

aliasLiteral
 : 'alias' referencePath?
 ;

typeParameterLiteral
 : 'given' referencePath?
 ;

newLiteral
 : 'new' referencePath?
 ;

valueLiteral
  : ('value' | 'object') referencePath
  ;

functionLiteral
  : 'function' referencePath
  ;

memberPathElement
    : member-name type-arguments?
    ;
    

memberModelExpression
    : memberPathElement 
    | package-qualifier memberPathElement
    | primaryType '.' memberPathElement
    ; 

typeModelExpression
    : type
    ;

modelExpression
  : memberModelExpression
  | typeModelExpression
  ;

metaLiteral
    : '`' (declaration-ref | modelExpression) '`'
    ;

modelRef
    : '^' modelExpression
    ;
    
declaration-ref
    : moduleLiteral
    | packageLiteral
    | classLiteral
    | newLiteral
    | interfaceLiteral
    | aliasLiteral
    | typeParameterLiteral
    | valueLiteral
    | functionLiteral
    ;


// Lexer

decimalDigits
    : decimalDigit ('_' | decimalDigit)*
    ;

hexDigits
    : hexDigit ('_' | hexDigit)*
    ;

binaryDigits
    : binaryDigit ('_' | binaryDigit)*
    ;

exponent
    : ( 'e' | 'E' ) ( '+' | '-' )? decimalDigit*
    ;

magnitude
    : 'k' | 'M' | 'G' | 'T' | 'P'
    ;

fractionalMagnitude
    : 'm' | 'u' | 'n' | 'p' | 'f'
    ;
    
literalFloat
    : < decimalDigits ( '.' decimalDigits (exponent | magnitude | fractionalMagnitude)? | fractionalMagnitude) >
    ;

literalNatural
    : < decimalDigits magnitude? | '#' hexDigits | '$' binaryDigits >
    ;

literalChar
    : < '\'' charPart '\'' >
    ;

stringStart
    : < '"' stringPart '``' >
    ;

stringMid
    : < '``' stringPart '``' >
    ;

stringEnd
    : < '``' stringPart '`'* '"' >
    ;

literalString
    : < '"' stringPart '`'* '"' >
    ;

verbatimString
    : < '"""' (~'"' | '"' ~'"' | '""' ~'"')* ('"' ('"' ('"' ('"' '"'?)?)?)?)? >
    ;

charPart
    : ( ~('\\' | '\'') | escapeSequence )*
    ;

stringPart
    : ( ~('\\'| '"'|'`') | ('`' ~('`'|'"'|'\\')) | '`\\' escapeCore | escapeSequence )*
    ;

escapeSequence
    : '\\' (~'{' | '{' (~'}')* '}' )
    ;

escapeCore
    : ~'{'
    | '{' (~'}')* '}'?
    ;

skip
    : white
    | comment
    ;

white
    : ( ' ' | '\r' | '\t' | '\f' | '\n' )+
    ;

lineEnd
    : '\r' '\n'
    | '\n'
    | '\r'
    ;

lineEnder
    : '\r'
    | '\n'
    ;

comment
    : lineComment
    | blockComment
    ;

hash-tag
    : < '#!' (~lineEnder)* lineEnd? >
    ;

lineComment
    :   '//' (~lineEnder)* lineEnd?
    ;   

blockComment
    : '/*' ( ~'*' | '*'+ ~('*'|'/') )* '*'+ '/'
    ;

LIDENTIFIER
    : < LIdentifierStart IdentifierPart* | LIdentifierPrefix IdentifierPart+ >
    ;

UIDENTIFIER 
    : < UIdentifierStart IdentifierPart* | UIdentifierPrefix IdentifierPart+ >
    ;

LIdentifierStart
    : '_'
    | 'a' .. 'z'
    ;

UIdentifierStart
    : 'A' .. 'Z'
    ;

LIdentifierPrefix
    : '\\i'
    ;

UIdentifierPrefix
    : '\\I'
    ;
    
IdentifierPart
    :   '_'
    |   decimalDigit
    |   Letter
    ;

Letter
    : 'a'..'z' 
    | 'A'..'Z' 
    | '\u{0080}'..'\u{ffff}'
    ;

decimalDigit
    : '0'..'9'
    ;

hexDigit
    : '0'..'9' | 'A'..'F' | 'a'..'f'
    ;

binaryDigit
    : '0' | '1'
    ;
