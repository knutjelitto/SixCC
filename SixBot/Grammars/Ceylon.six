grammar Ceylon;

%start      = compilation-unit ;
%whitespace = skip ;
%keywords   = LIDENTIFIER ;

compilation-unit
    | hash-tag? unit-elements
    ;

unit-elements
    | unit-element*
    ;

unit-element
    | module-descriptor
    | package-descriptor
    | import-declaration
    | declaration
    ;

module-descriptor
    | annotations 'module' module-name module-specifier version? module-body
    ;

module-specifier
    | repository ':' module (':' artifact (':' classifier)?)?
    ;

repository
    | any-name
    ;

module
    | literal-string
    | module-name
    ;

artifact
    | literal-string
    ;

classifier
    | literal-string
    ;

version
    | literal-string
    ;

   
module-name
    | package-path
    ;

module-body
    | '{' ( annotations (inferred-attribute-declaration | import-module) )* '}'
    ;

package-descriptor
    | annotations 'package' package-path ';'
    ;

import-module
    | 'import' (import-namespace ':')? (literal-string | package-path) ( ':' literal-string ( ':' literal-string )? )? (literal-string | member-name)? ';'
    ;

import-declaration
    | 'import' package-path import-elements
    ;

import-elements
    | '{' import-element-list? '}'
    ;

import-element-list
    | import-element (',' import-element)*
    ;

import-element
    | import-named
    | import-wildcard
    ;

import-named
    | import-name ('=' import-name)? import-elements?
    ;

import-wildcard
    | '...'
    ;

import-name
    | member-name
    | type-name
    ;

package-path
    | package-name ( '.' package-name )*
    ;

any-name
    | LIDENTIFIER
    | UIDENTIFIER
    ;

import-namespace
    | LIDENTIFIER
    | UIDENTIFIER
    ;

package-name
    | any-name
    ;

annotation-name
    | LIDENTIFIER
    ;

member-name
    | LIDENTIFIER
    ;
    
type-name
    | UIDENTIFIER
    ;

pattern
    | entry-pattern
    | tuple-pattern
    | variable-pattern
    ;

variable-or-tuple-pattern
    | tuple-pattern
    | variable-pattern
    ;

tuple-or-entry-pattern
    | entry-pattern
    | tuple-pattern
    ;

entry-pattern
    | variable-or-tuple-pattern '->' variable-or-tuple-pattern
    ;

tuple-pattern
    | '[' variadic-pattern-list? ']'
    ;

variadic-pattern-list
    | variadic-pattern (',' variadic-pattern)*
    ;

variadic-pattern
    | variadic-variable
    | pattern
    ;

variable-pattern
    | variable
    ;

variadic-variable
    | union-type? ('*' | '+') member-name?
    ;

destructure
    | 'let' '(' let-variable-list ')' ';'
    ;

let-variable-list
    | let-variable (',' let-variable)*
    ;

delegated-constructor
    | 'extends' class-instatiation
    ;

assertion
    | assertion-message? 'assert' conditions ';'
    ;

assertion-message
    | string-expression
    ;

block
    | '{' block-elements '}'
    ;

interface-block
    | '{' block-elements '}'
    ;

class-block
    | '{' block-elements '}'
    ;

block-elements
    | block-element*
    ;

block-element
    | import-declaration
    | declaration-or-statement
    ;

extended-type
    | 'extends' class-instatiation
    ;

class-specifier
    | '=>' class-instatiation
    ;

class-instatiation
    | (package-qualified-class | super-qualified-class | un-qualified-class) (positional-arguments | named-arguments)?
    ;

super-qualified-class
    | super-qualifier (type-reference | member-reference)
    ;

super-qualifier
    | 'super' '.'
    ;

package-qualified-class
    | package-qualifier type-reference ( '.' member-reference)?
    ;

package-qualifier
    | 'package' '.'
    ;

un-qualified-class
    | type-reference ( '.' ( member-reference | type-path )? )?
    | member-reference
    ;

type-path
    | type-reference ('.' type-reference)*
    ;

satisfied-types
    | 'satisfies' union-type (',' union-type )*
    ;

case-types
    | 'of' caseType ( '|' caseType )*
    ;

caseType
    | primary-type
    | member-name
    | package-qualifier member-name
    ;

parameters
    | '(' parameter-list? ')'
    ;

parameter-list
    | parameter-declaration-or-ref-pattern  (',' parameter-declaration-or-ref-pattern)*
    ;

parameter-declaration-or-ref-pattern
    | tuple-or-entry-pattern
    | parameter-declaration-or-ref
    ;

parameter-declaration-or-ref
    | parameter
    | parameter-reference
    ;

parameter
    | annotations parameter-declaration
    ;
    
parameter-reference
    | member-name value-specifier?
    ;

parameter-declaration
    | (variadic-type | 'void' | 'function' | 'dynamic' | 'value') member-name (value-specifier? | type-parameters? parameters+ any-specifier?)
    ;

type-parameters
    | '<' type-parameter-list '>'
    ;

type-parameter-list
    | type-parameter (',' type-parameter)*
    ;

type-parameter
    | variance? type-name type-default?
    ;

variance
    | 'in'
    | 'out'
    ;
    
type-default
    | '=' type
    ;

type-constraint
    | 'given' type-name? type-parameters? case-types? satisfied-types?
    ;

type-constraints
    | type-constraint+
    ;

declaration-or-statement
    | declaration
    | statement
    | destructure
    | assertion
    ;

declaration
    | constructor
    | enumerated-object
    | alias-declaration
    | object-declaration
    | setter-declaration
    | typed-method-declaration
    | inferred-method-declaration
    | typed-attribute-declaration
    | inferred-attribute-declaration
    | class-declaration
    | interface-declaration
    ;

constructor
    | annotations 'new' member-name? parameters? delegated-constructor? block
    ;

enumerated-object
    | annotations 'new' member-name delegated-constructor? block
    ;
    
alias-declaration
    | annotations 'alias' type-name type-parameters? type-constraints? type-specifier? ';'
    ;

object-declaration
    | annotations 'object' member-name extended-type? satisfied-types? class-block
    ;

setter-declaration
    | annotations 'assign' member-name (block | function-specifier ';')
    ;

typed-method-declaration
    | annotations (variadic-type | 'void' | 'dynamic') member-name type-parameters? parameters+ type-constraints? (block | function-specifier? ';')
    ;

inferred-method-declaration
    | annotations 'function' member-name type-parameters? parameters+ type-constraints? (block | function-specifier? ';')
    ;

typed-attribute-declaration
    | annotations (variadic-type | 'dynamic') member-name (block | any-specifier? ';')
    ;

inferred-attribute-declaration
    | annotations 'value' member-name (block | any-specifier? ';')
    ;

class-declaration
    | annotations 'class' 
      type-name
      type-parameters?
      parameters?
      case-types?
      extended-type?
      satisfied-types?
      type-constraints?
      (class-block | class-specifier? ';')
    ;

interface-declaration
    | annotations ('interface' | 'dynamic')
      type-name
      type-parameters?
      case-types?
      satisfied-types?
      type-constraints?
      (interface-block | type-specifier? ';')
    ;

statement
    | directive-statement ';'
    | expression-statement ';'
    | specification-statement ';'
    | control-statement
    ;

specification-statement
    | primary function-specifier
    ;
    
expression-statement
    | expression
    ;

directive-statement
    | return-directive
    | throw-directive
    | break-directive
    | continue-directive
    ;

return-directive
    | 'return' function-or-expression?
    ;

throw-directive
    | 'throw' function-or-expression?
    ;

break-directive
    | 'break'
    ;

continue-directive
    | 'continue'
    ;

type-specifier
    | '=>' type
    ;

value-specifier
    | '=' function-or-expression
    ;

function-specifier
    | '=>' function-or-expression
    ;

any-specifier
    | value-specifier
    | function-specifier
    ;

expression
    | assignment-expression
    ;

base-reference-or-parameterized
    | member-name type-parameters? parameters+
    | member-reference
    | type-reference
    | self-reference (member-selection-operator member-name type-parameters? parameters+)?
    ;

member-reference
    | member-name type-arguments?
    ;

type-reference
    | type-name type-arguments?
    ;

self-reference
    | 'this'
    | 'super' 
    | 'outer'
    | 'package'
    ;
    
enumeration
    | '{' declaration-or-statement* sequenced-arguments? '}'
    ;

tuple
    | '[' sequenced-arguments? ']'
    ;


named-arguments
    | '{' (named-argument | anonymous-argument)* sequenced-arguments? '}'
    ;

named-argument
    | named-specified-argument
    | named-argument-declaration
    ;

named-specified-argument
    | member-name value-specifier ';'
    ;

sequenced-arguments
    | sequenced-argument (',' sequenced-argument)* 
    ;

sequenced-argument
    | comprehension
    | positional-argument
    | spread-argument
    ;

anonymous-argument
    | function-or-expression ';'
    ;

named-argument-declaration
    | object-argument
    | typed-method-argument
    | inferred-method-argument
    | untyped-method-argument
    | typed-getter-argument
    | inferred-getter-argument
    | untyped-getter-argument
    ;

object-argument
    | 'object' member-name? extended-type? satisfied-types? class-block
    ;

typed-method-argument
    | (type | 'dynamic' | 'void') member-name type-parameters? parameters+ (block | function-specifier? ';')
    ;

typed-getter-argument
    | (type |'dynamic') member-name (block | function-specifier? ';')
    ;

inferred-method-argument
    | 'function' member-name? type-parameters? parameters (block | function-specifier? ';')
    ;

inferred-getter-argument
    | 'value' member-name (block | function-specifier? ';')
    ;

untyped-method-argument
    | member-name parameters+ function-specifier ';'
    ;

untyped-getter-argument
    | member-name function-specifier ';'
    ;

grouped-expression
    | '(' function-or-expression ')'
    ;
        
positional-arguments
    | '(' sequenced-arguments? ')'
    ;

positional-argument
    | function-or-expression
    | declaration-reference
    ;

spread-argument
    | '*' union-expression
    ;

function-or-expression
    | let-clause
    | if-expression
    | switch-expression
    | expression
    | anonymous-function
    ;

let-variable
    | pattern value-specifier
    ;

let-clause
    | 'let' '(' let-variable-list? ')' conditional-branch
    ;

switch-expression
    | switch-header case-expressions
    ;

case-expressions
    | case-expression+ else-expression?
    ;
    
case-expression
    | 'else'? 'case' '(' case-item ')' conditional-branch
    ;

else-expression
    | 'else' conditional-branch
    ;

if-expression
    | 'if' conditions then-expression else-expression
    ;

conditional-branch
    | if-expression
    | let-clause
    | disjunction-expression
    ;

then-expression
    | 'then' conditional-branch
    ;

anonymous-function
    | ('void' | 'function')? type-parameters? (parameters+ type-constraints?)? (block | function-specifier)
    ;

comprehension
    | for-comprehension-clause
    | if-comprehension-clause
    ;

comprehension-clause
    | for-comprehension-clause 
    | if-comprehension-clause 
    | expression-comprehension-clause 
    ;

expression-comprehension-clause
    | function-or-expression
    ;

for-comprehension-clause
    | 'for' for-iterator comprehension-clause
    ;
    
if-comprehension-clause
    | 'if' conditions comprehension-clause
    ;
    
assignment-expression
    | then-else-expression assignmentOperator function-or-expression
    | then-else-expression
    ;

assignmentOperator
    | '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '~='
    | '&&='
    | '||='
    ;

then-else-expression
    | then-else-expression then-else-operator disjunction-expression
    | disjunction-expression
    ;

then-else-operator
    | 'else' 
    | 'then'
    ;

disjunction-expression
    | disjunction-expression disjunction-operator conjunction-expression
    | conjunction-expression
    ;

disjunction-operator
    | '||' 
    ;

conjunction-expression
    | conjunction-expression conjunction-operator logicalNegationExpression
    | logicalNegationExpression
    ;

conjunction-operator
    | '&&' 
    ;

logicalNegationExpression
    | not-operator logicalNegationExpression
    | expressionOrMeta
    ;

not-operator
    | '!' 
    ;

expressionOrMeta
    | model-reference
    | equality-expression
    ;

equality-expression
    | comparison-expression equality-operator comparison-expression
    | comparison-expression
    ;

equality-operator
    | '==' 
    | '!='
    | '==='
    ;

comparison-expression
    | existenceEmptinessExpression comparison-operator existenceEmptinessExpression
    | existenceEmptinessExpression larger-operator existenceEmptinessExpression
    | existenceEmptinessExpression smaller-operator existenceEmptinessExpression smaller-operator existenceEmptinessExpression
    | existenceEmptinessExpression smaller-operator existenceEmptinessExpression
    | existenceEmptinessExpression type-operator type
    | existenceEmptinessExpression
    ;

smaller-operator
    | '<='
    | '<'
    ;

larger-operator
    | '>='
    | '>'
    ;

comparison-operator
    | '<=>' 
    | 'in'
    ;

type-operator
    | 'is'
    | 'extends'
    | 'satisfies'
    | 'of'
    ;

existenceEmptinessExpression
    | entryRangeExpression existsNonemptyOperator
    | entryRangeExpression
    ;

existsNonemptyOperator
    | 'exists' 
    | 'nonempty'
    ;

entryRangeExpression
    | additive-expression rangeIntervalEntryOperator additive-expression
    | additive-expression
    ;

rangeIntervalEntryOperator
    | '..' 
    | ':'
    | '->'
    ;

additive-expression
    | additive-expression additive-operator scale-expression
    | scale-expression
    ;

additive-operator
    | '+' 
    | '-'
    ;

scale-expression
    | multiplicative-expression scale-operator scale-expression
    | multiplicative-expression
    ;

scale-operator
    | '**' 
    ;

multiplicative-expression
    | multiplicative-expression multiplicative-operator union-expression
    | union-expression
    ;

multiplicative-operator
    | '*' 
    | '/'
    | '%'
    ;

union-expression
    | union-expression union-operator exclusive-expression
    | exclusive-expression
    ;
    
union-operator
    | '|'
    | '~'
    ;

exclusive-expression
    | exclusive-expression exclusive-operator intersection-expression
    | intersection-expression
    ;

exclusive-operator
    | '^' 
    ;

intersection-expression
    | intersection-expression intersection-operator negationComplementExpression
    | negationComplementExpression
    ;
    
intersection-operator
    | '&'
    ;

negationComplementExpression
    | unaryMinusOrComplementOperator negationComplementExpression
    | prefix-expression
    ;

unaryMinusOrComplementOperator
    | '-' !'-'
    | '+' !'+'
    | '~'
    ;

prefix-expression
    | prefix-operator prefix-expression
    | postfix-expression
    ;

postfix-expression
    | postfix-expression postfix-operator
    | primary
    ;

prefix-operator
    | '--'
    | '++'
    ;

postfix-operator
    | '--' 
    | '++' 
    ;

primary
    | primary qualified-reference
    | primary index-or-index-range
    | primary positional-arguments
    | primary named-arguments
    | base
    ;

qualified-reference
    | member-selection-operator (member-reference | type-reference)
    ;

member-selection-operator
    | '.'
    | '?.'
    | '*.'
    ;

index-or-index-range
    | '['
      ( '...' index
      | index '...'
      | index '..' index
      | index ':' index
      | function-or-expression
      )
      ']'
    ;
    
index
    | additive-expression 
    ;

base
    | nonstring-literal
    | string-expression
    | meta-literal
    | enumeration
    | tuple
    | object-expression
    | grouped-expression
    | base-reference-or-parameterized
    ;

nonstring-literal
    | literal-natural 
    | literal-float 
    | literal-char 
    ;

string-expression
    | string-literal
    | string-start function-or-expression (string-mid function-or-expression)* string-end
    ;

string-literal
    | literal-string 
    | verbatim-string
    ;

object-expression
    | 'object' extended-type? satisfied-types? class-block
    ;

type-arguments
    | '<' type-argument-list? '>'
    ;

type-argument-list
    | varianced-type (',' varianced-type)*
    ;

varianced-type
    | variance? type
    ;

defaulted-type-list
    | defaulted-type (',' defaulted-type )*
    ;

defaulted-type
    | type '='
    | variadic-type
    ;

variadic-type
    | union-type ('*' | '+')
    | type
    ;

spread-type
    | '*' union-type
    ;

type
    | entry-type
    | union-type
    ;

entry-type
    | union-type '->' union-type
    ;

union-type
    | union-type '|' intersection-type
    | intersection-type
    ;

intersection-type
    | intersection-type '&' primary-type
    | primary-type
    ;

primary-type
    | nullable-type
    | array-type
    | function-type
    | tuple-type
    | iterable-type
    | grouped-type
    | qualified-type
    ;

nullable-type
    | primary-type '?'
    ;

array-type
    | primary-type '[' literal-natural? ']'
    ;

function-type
    | primary-type '(' (spread-type | defaulted-type-list)? ')'
    ;

tuple-type
    | '[' (spread-type | defaulted-type-list)? ']'
    ;

iterable-type
    | '{' variadic-type? '}'
    ;

grouped-type
    | '<' type '>'
    ;

qualified-type
    | qualified-type '.' type-reference
    | package-qualifier? type-reference
    ;
    
annotations
    | string-literal? annotation*
    ;

annotation
    | annotation-name ( positional-arguments | named-arguments )?
    ;

conditions
    | '(' condition-list? ')'
    ;

condition-list
    | condition (',' condition)*
    ;

condition
    | exists-condition
    | nonempty-condition
    | is-condition 
    | satisfies-condition
    | boolean-condition
    ;
    
exists-condition
    | '!'? 'exists' (let-variable | expression)
    ;
    
nonempty-condition
    | '!'? 'nonempty' (let-variable | expression)
    ;

is-condition
    | '!'? 'is' type is-condition-variable
    ;

is-condition-variable
    | member-name value-specifier?
    ;

satisfies-condition
    | 'satisfies' type type-name
    ;

boolean-condition
    | function-or-expression
    ;

control-statement
    | if-else
    | switch-case-else 
    | while-loop
    | for-else
    | try-catch-finally
    | dynamic
    ;

dynamic
    | 'dynamic' block
    ;

if-else
    | if-block else-block?
    ;

if-block
    | 'if' conditions block
    ;

else-block
    | 'else' (if-else | block)
    ;

switch-case-else
    | switch-header cases
    ;

switch-header
    | 'switch' '(' switched ')'
    ;

switched
    | specified-variable
    | expression
    ;

cases
    | case-block+ else-block?
    ;
    
case-block
    | 'else'? 'case' '(' case-item ')' block
    ;

case-item
    | is-case-condition
    | satisfies-case-condition
    | match-case-condition
    | pattern
    ;

is-case-condition
    | 'is'? type
    ;

satisfies-case-condition
    | 'satisfies' type
    ;

match-case-condition
    | value-case-list
    ;

value-case-list
    | value-case ( (',' | '|') value-case)*
    ;

value-case
    | intersection-type
    | intersection-expression 
    ;

for-else
    | for-block fail-block?
    ;

for-block
    | 'for' for-iterator block
    ;

fail-block
    | 'else' block
    ;

for-iterator
    | '(' ( (tuple-or-entry-pattern | variable) containment? )? ')'
    ;
    
containment
    | ('in' | ':') expression
    ;
    
while-loop
    | while-block
    ;

while-block
    | 'while' conditions block
    ;

try-catch-finally
    | try-block catch-block* finally-block?
    ;

try-block
    | 'try' resources? block
    ;

catch-block
    | 'catch' catch-variable block
    ;

catch-variable
    | '(' variable? ')' 
    ;

finally-block
    | 'finally' block
    ;

resources
    | '(' resource-list? ')'
    ;

resource-list
    | resource (',' resource)*
    ;

resource
    | specified-variable
    | expression
    ;

specified-variable
    | variable value-specifier
    ;

variable
    | (type | 'void' | 'function' | 'value') member-name parameters*
    | member-name parameters*
    ;

model-reference
    | '^' model-expression
    ;
    
meta-literal
    | '`' (declaration-reference | model-expression) '`'
    ;

model-expression
    | member-model-expression
    | type-model-expression
    ;

member-model-expression
    | member-reference
    | package-qualifier member-reference
    | primary-type '.' member-reference
    ; 

type-model-expression
    | type
    ;

declaration-reference
    | module-literal
    | package-literal
    | class-literal
    | new-literal
    | interface-literal
    | alias-literal
    | type-parameter-literal
    | value-literal
    | function-literal
    ;

module-literal
    | 'module' package-path?
    ;

package-literal
    | 'package' package-path?
    ;

class-literal
    | 'class' reference-path
    ;

interface-literal
    | 'interface' reference-path
    ;

alias-literal
    | 'alias' reference-path
    ;

type-parameter-literal
    | 'given' reference-path
    ;

new-literal
    | 'new' reference-path
    ;

value-literal
    | ('value' | 'object') reference-path
    ;

function-literal
    | 'function' reference-path
    ;

reference-path
    | package-qualifier? reference-path-element ('.' reference-path-element)*
    ; 

reference-path-element
    | type-name 
    | member-name
    ;
    
// Lexer

decimal-digits
    | decimal-digit ('_' | decimal-digit)*
    ;

hex-digits
    | hex-digit ('_' | hex-digit)*
    ;

binary-digits
    | binary-digit ('_' | binary-digit)*
    ;

exponent
    | ( 'e' | 'E' ) ( '+' | '-' )? decimal-digit*
    ;

magnitude
    | 'k' | 'M' | 'G' | 'T' | 'P'
    ;

fractional-magnitude
    | 'm' | 'u' | 'n' | 'p' | 'f'
    ;
    
literal-float
    | < decimal-digits ( '.' decimal-digits (exponent | magnitude | fractional-magnitude)? | fractional-magnitude) >
    ;

literal-natural
    | < decimal-digits magnitude? | '#' hex-digits | '$' binary-digits >
    ;

literal-char
    | < '\'' char-part '\'' >
    ;

string-start
    | < '"' string-part '``' >
    ;

string-mid
    | < '``' string-part '``' >
    ;

string-end
    | < '``' string-part '`'* '"' >
    ;

literal-string
    | < '"' string-part '`'* '"' >
    ;

verbatim-string
    | < '"""' (~'"' | '"' ~'"' | '""' ~'"')* '"""' >
    ;

char-part
    | ( ~('\\' | '\'') | escape-sequence )*
    ;

string-part
    | ( ~('\\'| '"'|'`') | ('`' ~('`'|'"'|'\\')) | '`\\' escape-core | escape-sequence )*
    ;

escape-sequence
    | '\\' (~'{' | '{' (~'}')* '}' )
    ;

escape-core
    | ~'{'
    | '{' (~'}')* '}'?
    ;

skip
    | white
    | comment
    ;

white
    | ( ' ' | '\r' | '\t' | '\f' | '\n' )+
    ;

line-end
    | '\r' '\n'
    | '\n'
    | '\r'
    ;

line-ender
    | '\r'
    | '\n'
    ;

comment
    | line-comment
    | block-comment
    ;

hash-tag
    | < '#!' (~line-ender)* line-end? >
    ;

line-comment
    | '//' (~line-ender)* line-end?
    ;   

block-comment
    | '/*' ( ~'*' | '*'+ ~('*'|'/') )* '*'+ '/'
    ;

LIDENTIFIER
    | < lower-identifier-start identifier-part* | lower-identifier-prefix identifier-part+ >
    ;

UIDENTIFIER 
    | < upper-identifier-start identifier-part* | upper-identifier-prefix identifier-part+ >
    ;

lower-identifier-start
    | '_'
    | 'a' .. 'z'
    ;

upper-identifier-start
    | 'A' .. 'Z'
    ;

lower-identifier-prefix
    | '\\i'
    ;

upper-identifier-prefix
    | '\\I'
    ;
    
identifier-part
    |   '_'
    |   decimal-digit
    |   letter
    ;

letter
    | 'a'..'z' 
    | 'A'..'Z' 
    | '\u{0080}'..'\u{ffff}'
    ;

decimal-digit
    | '0'..'9'
    ;

hex-digit
    | '0'..'9' | 'A'..'F' | 'a'..'f'
    ;

binary-digit
    | '0' | '1'
    ;
