grammar Ceylon;

%start      : compilation-unit ;
%whitespace : skip ;
%keywords   : LIDENTIFIER ;

compilation-unit
    : hash-tag? unit-elements
    ;

unit-elements
    : unit-element*
    ;

unit-element
    : module-descriptor
    | package-descriptor
    | import-declaration
    | declaration
    ;

module-descriptor
    : annotations 'module' module-name
      (import-namespace ':' (literal-string | module-name) (':' literal-string (':' literal-string)? )? )?
      literal-string?
      module-body
    ;

module-name
    : package-path
    ;

module-body
    : '{' ( annotations (inferred-attribute-declaration | import-module) )* '}'
    ;

package-descriptor
    : annotations 'package' package-path ';'
    ;

import-module
    : 'import' (import-namespace ':')? (literal-string | package-path) ( ':' literal-string ( ':' literal-string )? )? (literal-string | member-name)? ';'
    ;

import-namespace
    : LIDENTIFIER
    | UIDENTIFIER
    ;

import-declaration
    : 'import' package-path import-element-list
    ;

import-element-list
    : '{' ((import-element | import-wildcard) (',' (import-element | import-wildcard))*)? '}'
    ;

import-element
    : import-name ('=' import-name)? import-element-list?
    ;

import-wildcard
    : '...'
    ;

import-name
    : member-name
    | type-name
    ;

package-path
    : package-name ( '.' package-name )*
    ;

any-name
    : LIDENTIFIER
    | UIDENTIFIER
    ;

package-name
    : any-name
    ;

annotation-name
    : LIDENTIFIER
    ;

member-name
    : LIDENTIFIER
    ;
    
type-name
    : UIDENTIFIER
    ;

object-expression
    : 'object' extended-type? satisfied-types? class-body
    ;

variableOrTuplePattern
    : tuple-pattern
    | variable-pattern
    ;

pattern
    : entry-pattern
    | tuple-pattern
    | variable-pattern
    ;

tuple-or-entry-pattern
    : entry-pattern
    | tuple-pattern
    ;

entry-pattern
    : variableOrTuplePattern '->' variableOrTuplePattern
    ;

tuple-pattern
    : '[' (variadic-pattern (',' variadic-pattern)*)? ']'
    ;

variable-pattern
    : variable
    ;

variadic-pattern
    : variadic-variable
    | pattern
    ;

variadic-variable
    : union-type? ('*' | '+') member-name?
    ;

destructure
    : 'let' '(' let-variable (',' let-variable)* ')' ';'
    ;

delegated-constructor
    : 'extends' class-instatiation
    ;

assertion
    : assertion-message 'assert' conditions ';'
    ;

assertion-message
    : string-expression?
    ;

block
    : '{' (import-declaration | declaration-or-statement)* '}'
    ;

interface-body
    : '{' (import-declaration | declaration-or-statement)* '}'
    ;

class-body
    : '{' (import-declaration | declaration-or-statement)* '}'
    ;

extended-type
    : 'extends' class-instatiation
    ;

class-specifier
    : ('=>' | '=') class-instatiation
    ;

class-instatiation
    : (package-qualified-class | super-qualified-class | un-qualified-class) (positional-arguments | named-arguments)?
    ;

super-qualified-class
    : super-qualifier (type-reference | member-reference)
    ;

super-qualifier
    : 'super' '.'
    ;

package-qualified-class
    : package-qualifier type-reference ( '.' member-reference)?
    ;

package-qualifier
    : 'package' '.'
    ;

un-qualified-class
    : type-reference ( '.' ( member-reference | type-reference ('.' type-reference)* )? )?
    | member-reference
    ;

satisfied-types
    : 'satisfies' union-type (',' union-type )*
    ;

case-types
    : 'of' caseType ( '|' caseType )*
    ;

caseType
    : primary-type
    | member-name
    | package-qualifier member-name
    ;

parameters
    : '(' (parameter-declaration-or-ref-pattern  (',' parameter-declaration-or-ref-pattern)*)? ')'
    ;

parameter-declaration-or-ref-pattern
    : tuple-or-entry-pattern
    | parameter-declaration-or-ref
    ;

parameter-declaration-or-ref
    : parameter
    | parameter-reference
    ;

parameter
    : annotations parameter-declaration
    ;
    
parameter-reference
    : member-name specifier?
    ;

parameter-declaration
    : (variadic-type | 'void' | 'function' | 'dynamic' | 'value')
      member-name
      (specifier? | type-parameters? parameters+ function-specifier?)
    ;

type-parameters
    : '<' type-parameter ( ',' type-parameter )* '>'
    ;

type-parameter
    : variance? type-name type-default?
    ;

variance
    : 'in'
    | 'out'
    ;
    
type-constraint
    : 'given' type-name? type-parameters? case-types? satisfied-types?
    ;

type-constraints
    : type-constraint+
    ;

declaration-or-statement
    : declaration
    | statement
    | destructure
    | assertion
    ;

declaration
    : constructor
    | enumerated-object
    | alias-declaration
    | object-declaration
    | setter-declaration
    | typed-method-declaration
    | inferred-method-declaration
    | typed-attribute-declaration
    | inferred-attribute-declaration
    | class-declaration
    | interface-declaration
    ;

constructor
    : annotations 'new' member-name? parameters? delegated-constructor? block
    ;

enumerated-object
    : annotations 'new' member-name delegated-constructor? block
    ;
    
alias-declaration
    : annotations 'alias' type-name type-parameters? type-constraints? type-specifier? ';'
    ;

object-declaration
    : annotations 'object' member-name extended-type? satisfied-types? class-body
    ;

setter-declaration
    : annotations 'assign' member-name (block | function-specifier ';')
    ;

typed-method-declaration
    : annotations (variadic-type | 'void' | 'dynamic') member-name type-parameters? parameters+ type-constraints? (block | function-specifier? ';')
    ;

inferred-method-declaration
    : annotations 'function' member-name type-parameters? parameters+ type-constraints? (block | function-specifier? ';')
    ;

typed-attribute-declaration
    : annotations (variadic-type | 'dynamic') member-name (block | function-specifier? ';')
    ;

inferred-attribute-declaration
    : annotations 'value' member-name (block | function-specifier? ';')
    ;

class-declaration
    : annotations 'class' 
      type-name
      type-parameters?
      parameters?
      case-types?
      extended-type?
      satisfied-types?
      type-constraints?
      (class-body | class-specifier? ';')
    ;

interface-declaration
    : annotations ('interface' | 'dynamic')
      type-name
      type-parameters?
      case-types?
      satisfied-types?
      type-constraints?
      (interface-body | type-specifier? ';')
    ;

statement
    : directive-statement ';'
    | expression-statement ';'
    | specification-statement ';'
    | control-statement
    ;

specification-statement
    : value-expression lazy-specifier
    ;
    
expression-statement
    : expression
    ;

directive-statement
    : return-directive
    | throw-directive
    | break-directive
    | continue-directive
    ;

return-directive
    : 'return' function-or-expression?
    ;

throw-directive
    : 'throw' function-or-expression?
    ;

break-directive
    : 'break'
    ;

continue-directive
    : 'continue'
    ;

type-specifier
    : ('=>' | '=') type
    ;

type-default
    : '=' type
    ;

specifier
    : '=' function-or-expression
    ;

lazy-specifier
    : '=>' function-or-expression
    ;

function-specifier
    : specifier
    | lazy-specifier
    ;

expression
    : assignment-expression
    ;

base-reference-or-parameterized
    : member-name type-parameters? parameters+
    | member-reference
    | type-reference
    | self-reference (member-selection-operator member-name type-parameters? parameters+)?
    ;

member-reference
    : member-name type-arguments?
    ;

type-reference
    : type-name type-arguments?
    ;

qualified-reference
    : member-selection-operator (member-reference | type-reference)
    ;

self-reference
    : 'this'
    | 'super' 
    | 'outer'
    | 'package'
    ;
    
member-selection-operator
    : '.'
    | '?.'
    | '*.'
    ;

index-or-index-range
    : '['
      ( '...' index
      | index '...'
      | index '..' index
      | index ':' index
      | function-or-expression
      )
      ']'
    ;
    
index
    : additive-expression 
    ;

enumeration
    : '{' declaration-or-statement* sequenced-arguments? '}'
    ;

tuple
    : '[' sequenced-arguments? ']'
    ;


named-arguments
    : '{' (named-argument | anonymous-argument)* sequenced-arguments? '}'
    ;

named-argument
    : named-specified-argument
    | named-argument-declaration
    ;

named-specified-argument
    : member-name specifier ';'
    ;

sequenced-arguments
    : sequenced-argument (',' sequenced-argument)* 
    ;

sequenced-argument
    : comprehension
    | positional-argument
    | spread-argument
    ;

anonymous-argument
    : function-or-expression ';'
    ;

named-argument-declaration
    : object-argument
    | typed-method-argument
    | inferred-method-argument
    | untyped-method-argument
    | typed-getter-argument
    | inferred-getter-argument
    | untyped-getter-argument
    ;

object-argument
    : 'object' member-name? extended-type? satisfied-types? class-body
    ;

typed-method-argument
    : (type | 'dynamic' | 'void') member-name type-parameters? parameters+ (block | function-specifier? ';')
    ;

typed-getter-argument
    : (type |'dynamic') member-name (block | function-specifier? ';')
    ;

inferred-method-argument
    : 'function' member-name? type-parameters? parameters (block | function-specifier? ';')
    ;

inferred-getter-argument
    : 'value' member-name (block | function-specifier? ';')
    ;

untyped-method-argument
    : member-name parameters+ function-specifier ';'
    ;

untyped-getter-argument
    : member-name lazy-specifier ';'
    ;

grouped-expression
    : '(' function-or-expression ')'
    ;
        
positional-arguments
    : '(' sequenced-arguments? ')'
    ;

positional-argument
    : function-or-expression
    | declaration-reference
    ;

spread-argument
    : '*' union-expression
    ;

function-or-expression
    : let-clause
    | if-expression
    | switch-expression
    | expression
    | anonymous-function
    ;

let-variable
    : pattern specifier
    ;

let-clause
    : 'let' '(' (let-variable (',' let-variable)*)? ')' conditional-branch
    ;

switch-expression
    : switch-header case-expressions
    ;

case-expressions
    : case-expression+ else-expression?
    ;
    
case-expression
    : 'else'? 'case' case-item-list conditional-branch
    ;

else-expression
    : 'else' conditional-branch
    ;

if-expression
    : 'if' conditions then-expression else-expression
    ;

conditional-branch
    : if-expression
    | let-clause
    | disjunction-expression
    ;

then-expression
    : 'then' conditional-branch
    ;

anonymous-function
    : ('void' | 'function')? type-parameters? (parameters+ type-constraints?)? (block | lazy-specifier)
    ;

comprehension
    : for-comprehension-clause
    | if-comprehension-clause
    ;

comprehension-clause
    : for-comprehension-clause 
    | if-comprehension-clause 
    | expression-comprehension-clause 
    ;

expression-comprehension-clause
    : function-or-expression
    ;

for-comprehension-clause
    : 'for' for-iterator comprehension-clause
    ;
    
if-comprehension-clause
    : 'if' conditions comprehension-clause
    ;
    
assignment-expression
    : then-else-expression assignmentOperator function-or-expression
    | then-else-expression
    ;

assignmentOperator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '~='
    | '&&='
    | '||='
    ;

then-else-expression
    : then-else-expression then-else-operator disjunction-expression
    | disjunction-expression
    ;

then-else-operator
    : 'else' 
    | 'then'
    ;

disjunction-expression
    : disjunction-expression disjunction-operator conjunction-expression
    | conjunction-expression
    ;

disjunction-operator
    : '||' 
    ;

conjunction-expression
    : conjunction-expression conjunction-operator logicalNegationExpression
    | logicalNegationExpression
    ;

conjunction-operator
    : '&&' 
    ;

logicalNegationExpression
    : not-operator logicalNegationExpression
    | expressionOrMeta
    ;

not-operator
    : '!' 
    ;

expressionOrMeta
    : model-reference
    | equality-expression
    ;

equality-expression
    : comparison-expression equality-operator comparison-expression
    | comparison-expression
    ;

equality-operator
    : '==' 
    | '!='
    | '==='
    ;

comparison-expression
    : existenceEmptinessExpression comparison-operator existenceEmptinessExpression
    | existenceEmptinessExpression larger-operator existenceEmptinessExpression
    | existenceEmptinessExpression smaller-operator existenceEmptinessExpression smaller-operator existenceEmptinessExpression
    | existenceEmptinessExpression smaller-operator existenceEmptinessExpression
    | existenceEmptinessExpression type-operator type
    | existenceEmptinessExpression
    ;

smaller-operator
    : '<='
    | '<'
    ;

larger-operator
    : '>='
    | '>'
    ;

comparison-operator
    : '<=>' 
    | 'in'
    ;

type-operator
    : 'is'
    | 'extends'
    | 'satisfies'
    | 'of'
    ;

existenceEmptinessExpression
    : entryRangeExpression existsNonemptyOperator
    | entryRangeExpression
    ;

existsNonemptyOperator
    : 'exists' 
    | 'nonempty'
    ;

entryRangeExpression
    : additive-expression rangeIntervalEntryOperator additive-expression
    | additive-expression
    ;

rangeIntervalEntryOperator
    : '..' 
    | ':'
    | '->'
    ;

additive-expression
    : additive-expression additive-operator scale-expression
    | scale-expression
    ;

additive-operator
    : '+' 
    | '-'
    ;

scale-expression
    : multiplicative-expression scale-operator scale-expression
    | multiplicative-expression
    ;

scale-operator
    : '**' 
    ;

multiplicative-expression
    : multiplicative-expression multiplicative-operator union-expression
    | union-expression
    ;

multiplicative-operator
    : '*' 
    | '/'
    | '%'
    ;

union-expression
    : union-expression union-operator intersection-expression
    | intersection-expression
    ;
    
union-operator
    : '|'
    | '~'
    ;

intersection-expression
    : intersection-expression intersection-operator negationComplementExpression
    | negationComplementExpression
    ;
    
intersection-operator
    : '&'
    ;

negationComplementExpression
    : unaryMinusOrComplementOperator negationComplementExpression
    | exponentiation-expression
    ;

unaryMinusOrComplementOperator
    : '-' !'-'
    | '+' !'+'
    | '~'
    ;

exponentiation-expression
    : incrementDecrementExpression exponentiation-operator exponentiation-expression
    | incrementDecrementExpression
    ;

exponentiation-operator
    : '^' 
    ;

incrementDecrementExpression
    : prefixOperator incrementDecrementExpression
    | postfixIncrementDecrementExpression
    ;

prefixOperator
    : '--'
    | '++'
    ;

postfixIncrementDecrementExpression
    : postfixIncrementDecrementExpression postfixOperator
    | value-expression
    ;

postfixOperator
    : '--' 
    | '++' 
    ;

value-expression
    : primary
    ;

primary
    : primary qualified-reference
    | primary index-or-index-range
    | primary positional-arguments
    | primary named-arguments
    | base
    ;

base
    : nonstring-literal
    | string-expression
    | meta-literal
    | enumeration
    | tuple
    | object-expression
    | grouped-expression
    | base-reference-or-parameterized
    ;

nonstring-literal
    : literal-natural 
    | literal-float 
    | literal-char 
    ;

string-literal
    : literal-string 
    | verbatim-string
    ;

string-expression
    : string-literal
    | string-start function-or-expression (string-mid function-or-expression)* string-end
    ;

type-arguments
    : '<' ( ( variance type? | type) (',' (variance type | type) )* )? '>'
    ;

defaulted-type
    : type '='
    | variadic-type
    ;

variadic-type
    : union-type ('*' | '+')
    | type
    ;

spread-type
    : '*' union-type?
    ;

type
    : entry-type
    | union-type
    ;

entry-type
    : union-type '->' union-type
    ;

union-type
    : union-type '|' intersection-type
    | intersection-type
    ;

intersection-type
    : intersection-type '&' primary-type
    | primary-type
    ;

primary-type
    : nullable-type
    | array-type
    | function-type
    | atomic-type
    ;

nullable-type
    : primary-type '?'
    ;

array-type
    : primary-type '[' literal-natural? ']'
    ;

function-type
    : primary-type '(' ( spread-type | defaulted-type (',' defaulted-type)* )? ')'
    ;

atomic-type
    : qualified-type
    | tuple-type
    | iterable-type
    ;

qualified-type
    : qualified-type '.' type-reference
    | package-qualifier? type-reference
    | grouped-type
    ;
    
tuple-type
    : '[' (spread-type | defaulted-type (',' defaulted-type )*)? ']'
    ;

iterable-type
   : '{' variadic-type? '}'
   ;

grouped-type
    : '<' type '>'
    ;

annotations
    : string-literal? annotation*
    ;

annotation
    : annotation-name ( positional-arguments | named-arguments )?
    ;

conditions
    : '(' condition-list? ')'
    ;

condition-list
    : condition (',' condition)*
    ;

condition
    : exists-condition
    | nonempty-condition
    | is-condition 
    | satisfies-condition
    | boolean-condition
    ;
    
exists-condition
    : '!'? 'exists' (let-variable | expression)
    ;
    
nonempty-condition
    : '!'? 'nonempty' (let-variable | expression)
    ;

is-condition
    : '!'? 'is' type is-condition-variable
    ;

is-condition-variable
    : member-name specifier?
    ;

satisfies-condition
    : 'satisfies' type type-name
    ;

boolean-condition
    : function-or-expression
    ;

control-statement
    : if-else
    | switch-case-else 
    | while-loop
    | for-else
    | try-catch-finally
    | dynamic
    ;

control-block
    : block
    ;

dynamic
    : 'dynamic' block
    ;

if-else
    : if-block else-block?
    ;

if-block
    : 'if' conditions control-block
    ;

else-block
    : 'else' (if-else | block)
    ;

switch-case-else
    : switch-header cases
    ;

switch-header
    : 'switch' '(' switched ')'
    ;

switched
    : specified-variable
    | expression
    ;

cases
    : case-block+ else-block?
    ;
    
case-block
    : 'else'? 'case' case-item-list block
    ;

case-item-list
    : '(' case-item ')' 
    ;

case-item
    : is-case-condition
    | satisfies-case-condition
    | match-case-condition
    | pattern
    ;

is-case-condition
    : 'is'? type
    ;

satisfies-case-condition
    : 'satisfies' type
    ;

match-case-condition
    : value-case-list
    ;

value-case-list
    : value-case ( (',' | '|') value-case)*
    ;

value-case
    : intersection-type
    | intersection-expression 
    ;

for-else
    : for-block fail-block?
    ;

for-block
    : 'for' for-iterator control-block
    ;

fail-block
    : 'else' control-block
    ;

for-iterator
    : '(' ( (tuple-or-entry-pattern | variable) containment? )? ')'
    ;
    
containment
    : ('in' | ':') expression?
    ;
    
while-loop
    : while-block
    ;

while-block
    : 'while' conditions control-block
    ;

try-catch-finally
    : try-block catch-block* finally-block?
    ;

try-block
    : 'try' (resources control-block | block)
    ;

catch-block
    : 'catch' catch-variable control-block
    ;

catch-variable
    : '(' variable? ')' 
    ;

finally-block
    : 'finally' control-block
    ;

resources
    : '(' ( resource (',' resource)* )? ')'
    ;

resource
    : specified-variable
    | expression
    ;

specified-variable
    : variable specifier
    ;

variable
    : (type | 'void' | 'function' | 'value') member-name parameters*
    | member-name parameters*
    ;

reference-path
    : package-qualifier? reference-path-element ('.' reference-path-element)*
    ; 

reference-path-element
    : type-name 
    | member-name
    ;
    
module-literal
 : 'module' package-path?
 ;

package-literal
 : 'package' package-path?
 ;

class-literal
 : 'class' reference-path
 ;

interface-literal
 : 'interface' reference-path
 ;

alias-literal
 : 'alias' reference-path
 ;

type-parameter-literal
 : 'given' reference-path
 ;

new-literal
 : 'new' reference-path
 ;

value-literal
  : ('value' | 'object') reference-path
  ;

function-literal
  : 'function' reference-path
  ;

member-path-element
    : member-name type-arguments?
    ;
    

member-model-expression
    : member-path-element 
    | package-qualifier member-path-element
    | primary-type '.' member-path-element
    ; 

type-model-expression
    : type
    ;

model-expression
  : member-model-expression
  | type-model-expression
  ;

meta-literal
    : '`' (declaration-reference | model-expression) '`'
    ;

model-reference
    : '^' model-expression
    ;
    
declaration-reference
    : module-literal
    | package-literal
    | class-literal
    | new-literal
    | interface-literal
    | alias-literal
    | type-parameter-literal
    | value-literal
    | function-literal
    ;


// Lexer

decimal-digits
    : decimal-digit ('_' | decimal-digit)*
    ;

hex-digits
    : hex-digit ('_' | hex-digit)*
    ;

binary-digits
    : binary-digit ('_' | binary-digit)*
    ;

exponent
    : ( 'e' | 'E' ) ( '+' | '-' )? decimal-digit*
    ;

magnitude
    : 'k' | 'M' | 'G' | 'T' | 'P'
    ;

fractional-magnitude
    : 'm' | 'u' | 'n' | 'p' | 'f'
    ;
    
literal-float
    : < decimal-digits ( '.' decimal-digits (exponent | magnitude | fractional-magnitude)? | fractional-magnitude) >
    ;

literal-natural
    : < decimal-digits magnitude? | '#' hex-digits | '$' binary-digits >
    ;

literal-char
    : < '\'' char-part '\'' >
    ;

string-start
    : < '"' string-part '``' >
    ;

string-mid
    : < '``' string-part '``' >
    ;

string-end
    : < '``' string-part '`'* '"' >
    ;

literal-string
    : < '"' string-part '`'* '"' >
    ;

verbatim-string
    : < '"""' (~'"' | '"' ~'"' | '""' ~'"')* ('"' ('"' ('"' ('"' '"'?)?)?)?)? >
    ;

char-part
    : ( ~('\\' | '\'') | escape-sequence )*
    ;

string-part
    : ( ~('\\'| '"'|'`') | ('`' ~('`'|'"'|'\\')) | '`\\' escape-core | escape-sequence )*
    ;

escape-sequence
    : '\\' (~'{' | '{' (~'}')* '}' )
    ;

escape-core
    : ~'{'
    | '{' (~'}')* '}'?
    ;

skip
    : white
    | comment
    ;

white
    : ( ' ' | '\r' | '\t' | '\f' | '\n' )+
    ;

line-end
    : '\r' '\n'
    | '\n'
    | '\r'
    ;

line-ender
    : '\r'
    | '\n'
    ;

comment
    : line-comment
    | block-comment
    ;

hash-tag
    : < '#!' (~line-ender)* line-end? >
    ;

line-comment
    :   '//' (~line-ender)* line-end?
    ;   

block-comment
    : '/*' ( ~'*' | '*'+ ~('*'|'/') )* '*'+ '/'
    ;

LIDENTIFIER
    : < LIdentifierStart IdentifierPart* | LIdentifierPrefix IdentifierPart+ >
    ;

UIDENTIFIER 
    : < UIdentifierStart IdentifierPart* | UIdentifierPrefix IdentifierPart+ >
    ;

LIdentifierStart
    : '_'
    | 'a' .. 'z'
    ;

UIdentifierStart
    : 'A' .. 'Z'
    ;

LIdentifierPrefix
    : '\\i'
    ;

UIdentifierPrefix
    : '\\I'
    ;
    
IdentifierPart
    :   '_'
    |   decimal-digit
    |   Letter
    ;

Letter
    : 'a'..'z' 
    | 'A'..'Z' 
    | '\u{0080}'..'\u{ffff}'
    ;

decimal-digit
    : '0'..'9'
    ;

hex-digit
    : '0'..'9' | 'A'..'F' | 'a'..'f'
    ;

binary-digit
    : '0' | '1'
    ;
