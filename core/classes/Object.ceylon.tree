CXStart
    CCodeUnit
        CNamespace
            CAnnotations
                ROptional<ICStringLiteral>
                RStar<CAnnotation>
            RLiteral{'namespace'}
            CNamespacePath
                CIdentifier{'six'}
                CIdentifier{'core'}
            RLiteral{';'}
        CImports
        CTopDeclarations
            CClassDeclaration
                CAnnotations
                    ROptional<ICStringLiteral>
                        CVerbatimString{'\"\"\"\r\nThe abstract supertype of all types representing definite values. Any two values which are\r\nassignable to `Object` may be compared for value equality using the `==` and `!=` operators, even\r\nif the values are of different concrete type:\r\n\r\n    true == false\r\n    1 == \"hello world\"\r\n    \"hello\" + \" \" + \"world\" == \"hello world\"\r\n    Singleton(\"hello world\") == [\"hello world\"]\r\n\r\nHowever, since [[Null]] is not a subtype of `Object`, the value [[null]] cannot be compared to any\r\nother value using the `==` operator. Thus, value equality is not defined for optional types. This\r\nneatly bypasses the problem of deciding the value of the expression `null==null`, which is simply illegal.\r\n\r\nA concrete subclass of `Object` must refine [[equals]] and [[hash]] (or inherit concrete refinements),\r\nproviding a concrete definition of value equality for the class.\r\n\r\nIn extreme cases it is acceptable for two values to be equal even when they are not instances of the\r\nsame class. For example, the [[Integer]] value `1` and the [[Float]] value `1.0` are considered equal.\r\nExcept in these extreme cases, instances of different classes are considered unequal.\r\n\"\"\"'}
                    RStar<CAnnotation>
                        CAnnotation
                            CLowerIdentifier{'see'}
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                        CSequencedArgumentList
                                            CClassLiteral
                                                RLiteral{'class'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'Basic'}
                                            CClassLiteral
                                                RLiteral{'class'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'Null'}
                                    RLiteral{')'}
                        CAnnotation
                            CLowerIdentifier{'by'}
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                        CSequencedArgumentList
                                            CLiteralString{'\"Gavin\"'}
                                    RLiteral{')'}
                        CAnnotation
                            CLowerIdentifier{'tagged'}
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                        CSequencedArgumentList
                                            CLiteralString{'\"Basic types\"'}
                                    RLiteral{')'}
                        CAnnotation
                            CLowerIdentifier{'shared'}
                            ROptional<ICArguments>
                        CAnnotation
                            CLowerIdentifier{'abstract'}
                            ROptional<ICArguments>
                RLiteral{'class'}
                CUpperIdentifier{'Object'}
                ROptional<CTypeParameters>
                ROptional<CParameters>
                    CParameters
                        RLiteral{'('}
                        ROptional<CParameterList>
                        RLiteral{')'}
                ROptional<CCaseTypes>
                ROptional<CExtendedType>
                    CExtendedType
                        RLiteral{'extends'}
                        CClassInstantiation
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'Anything'}
                                    ROptional<CTypeArguments>
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                    RLiteral{')'}
                ROptional<CSatisfiedTypes>
                ROptional<CTypeConstraints>
                CBlock
                    RLiteral{'{'}
                    CImports
                    CStatements
                        CTypedMethodDeclaration
                            CAnnotations
                                ROptional<ICStringLiteral>
                                    CLiteralString{'\"Determine if two values are equal.\r\n     \r\n     For any two non-null objects `x` and `y`, `x.equals(y)`\r\n     may be written as:\r\n     \r\n         x == y \r\n     \r\n     Implementations should respect the constraints that:\r\n     \r\n     - if `x===y` then `x==y` (reflexivity), \r\n     - if `x==y` then `y==x` (symmetry), \r\n     - if `x==y` and `y==z` then `x==z` (transitivity).\r\n     \r\n     Furthermore it is recommended that implementations\r\n     ensure that if `x==y` then `x` and `y` have the same \r\n     concrete class.\r\n     \r\n     A class which explicitly refines `equals()` is said to \r\n     support _value equality_, and the equality operator \r\n     `==` is considered much more meaningful for such \r\n     classes than for a class which simply inherits the\r\n     default implementation of _identity equality_ from\r\n     [[Identifiable]].\r\n     \r\n     Note that an implementation of `equals()` that always\r\n     returns [[false]] does satisfy the constraints given\r\n     above, as long as the class does _not_ inherit \r\n     [[Identifiable]]. Therefore, in very rare cases where \r\n     there is no reasonable definition of value equality for \r\n     a class, for example, [[function references|Callable]], \r\n     it is acceptable for `equals()` to be defined to return \r\n     `false` for every argument.\"'}
                                RStar<CAnnotation>
                                    CAnnotation
                                        CLowerIdentifier{'shared'}
                                        ROptional<ICArguments>
                                    CAnnotation
                                        CLowerIdentifier{'formal'}
                                        ROptional<ICArguments>
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'Boolean'}
                                    ROptional<CTypeArguments>
                            CLowerIdentifier{'equals'}
                            ROptional<CTypeParameters>
                            RPlus<CParameters>
                                CParameters
                                    RLiteral{'('}
                                    ROptional<CParameterList>
                                        CParameterList
                                            CParameter
                                                CAnnotations
                                                    ROptional<ICStringLiteral>
                                                    RStar<CAnnotation>
                                                CTypedValueParameter
                                                    CTypePath
                                                        CTypeReference
                                                            CUpperIdentifier{'Object'}
                                                            ROptional<CTypeArguments>
                                                    CLowerIdentifier{'that'}
                                                    ROptional<CValueSpecifier>
                                    RLiteral{')'}
                            ROptional<CTypeConstraints>
                            COptionalFunctionSpecifier
                                ROptional<CFunctionSpecifier>
                                RLiteral{';'}
                        CTypedAttributeDeclaration
                            CAnnotations
                                ROptional<ICStringLiteral>
                                    CLiteralString{'\"The hash value of the value, which allows the value to \r\n     be an element of a hash-based set or key of a\r\n     hash-based map. Implementations must respect the\r\n     constraint that:\r\n     \r\n     - if `x==y` then `x.hash==y.hash`.\r\n     \r\n     Therefore, a class which refines [[equals]] must also\r\n     refine `hash`.\r\n     \r\n     In general, `hash` values vary between platforms and\r\n     between executions of the same program.\r\n     \r\n     Note that when executing on a Java Virtual Machine, the \r\n     64-bit [[Integer]] value returned by an implementation \r\n     of `hash` is truncated to a 32-bit integer value by \r\n     taking the exclusive disjunction of the 32 lowest-order\r\n     bits with the 32 highest-order bits, before returning\r\n     the value to the caller.\"'}
                                RStar<CAnnotation>
                                    CAnnotation
                                        CLowerIdentifier{'see'}
                                        ROptional<ICArguments>
                                            CPositionalArguments
                                                RLiteral{'('}
                                                ROptional<CSequencedArgumentList>
                                                    CSequencedArgumentList
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'identityHash'}
                                                RLiteral{')'}
                                    CAnnotation
                                        CLowerIdentifier{'shared'}
                                        ROptional<ICArguments>
                                    CAnnotation
                                        CLowerIdentifier{'formal'}
                                        ROptional<ICArguments>
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'Integer'}
                                    ROptional<CTypeArguments>
                            CLowerIdentifier{'hash'}
                            COptionalAnySpecifier
                                ROptional<ICAnySpecifier>
                                RLiteral{';'}
                        CTypedAttributeDeclaration
                            CAnnotations
                                ROptional<ICStringLiteral>
                                    CLiteralString{'\"A developer-friendly string representing the instance. \r\n     Concatenates the name of the concrete class of the \r\n     instance with the `hash` of the instance. Subclasses \r\n     are encouraged to refine this implementation to produce \r\n     a more meaningful representation.\"'}
                                RStar<CAnnotation>
                                    CAnnotation
                                        CLowerIdentifier{'shared'}
                                        ROptional<ICArguments>
                                    CAnnotation
                                        CLowerIdentifier{'default'}
                                        ROptional<ICArguments>
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'String'}
                                    ROptional<CTypeArguments>
                            CLowerIdentifier{'string'}
                            COptionalAnySpecifier
                                ROptional<ICAnySpecifier>
                                    CFunctionSpecifier
                                        RLiteral{'=>'}
                                        CAdditiveExpr
                                            CAdditiveExpr
                                                CCallExpr
                                                    CMemberReference
                                                        CLowerIdentifier{'className'}
                                                        ROptional<CTypeArguments>
                                                    CPositionalArguments
                                                        RLiteral{'('}
                                                        ROptional<CSequencedArgumentList>
                                                            CSequencedArgumentList
                                                                CSelfReference{'this'}
                                                        RLiteral{')'}
                                                CAdditiveOperator{'+'}
                                                CLiteralString{'\"@\"'}
                                            CAdditiveOperator{'+'}
                                            CCallExpr
                                                CSelectionExpr
                                                    CTypeReference
                                                        CUpperIdentifier{'Integer'}
                                                        ROptional<CTypeArguments>
                                                    CMemberSelectionOperator{'.'}
                                                    CMemberReference
                                                        CLowerIdentifier{'format'}
                                                        ROptional<CTypeArguments>
                                                CPositionalArguments
                                                    RLiteral{'('}
                                                    ROptional<CSequencedArgumentList>
                                                        CSequencedArgumentList
                                                            CMemberReference
                                                                CLowerIdentifier{'hash'}
                                                                ROptional<CTypeArguments>
                                                            CLiteralNatural{'#10'}
                                                    RLiteral{')'}
                                RLiteral{';'}
                    RLiteral{'}'}
    REof{''}
