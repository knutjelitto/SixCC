CXStart
    CCodeUnit
        CNamespace
            CAnnotations
                ROptional<ICStringLiteral>
                RStar<CAnnotation>
            RLiteral{'namespace'}
            CNamespacePath
                CIdentifier{'six'}
                CIdentifier{'core'}
            RLiteral{';'}
        CImports
            CImportDeclaration
                RLiteral{'import'}
                CPackagePath
                    CIdentifier{'ceylon'}
                    CIdentifier{'language'}
                    CIdentifier{'meta'}
                CImportElements
                    RLiteral{'{'}
                    ROptional<CImportElementList>
                        CImportElementList
                            CImportNamed
                                CIdentifier{'annotations'}
                                ROptional<CImportNameSpecifier>
                                ROptional<CImportElements>
                            CImportNamed
                                CIdentifier{'optionalAnnotation'}
                                ROptional<CImportNameSpecifier>
                                ROptional<CImportElements>
                            CImportNamed
                                CIdentifier{'sequencedAnnotations'}
                                ROptional<CImportNameSpecifier>
                                ROptional<CImportElements>
                    RLiteral{'}'}
        CTopDeclarations
            CInterfaceDeclaration
                CAnnotations
                    ROptional<ICStringLiteral>
                        CVerbatimString{'\"\"\"\r\nThe supertype of all *annotation classes*. \r\n\r\n### Annotation classes\r\n\r\nAn *annotation class* must satisfy `Annotation`, [[OptionalAnnotation]],  or [[SequencedAnnotation]] and must be\r\nannotated `final annotation`. For example:\r\n\r\n    \"An annotation class.\"\r\n    final annotation class Example(shared String description) \r\n        satisfies Annotation {}\r\n\r\nAnnotation classes which satisfy `Annotation` directly may be applied to any program element that supports annotations\r\n(see [[Annotated]]). In practice, annotation classes often satisfy [[OptionalAnnotation]] or [[SequencedAnnotation]] in\r\norder to prevent annotations being applied to inappropriate program elements.\r\n\r\nEach initializer parameter of an annotation class must have one of the following types:\r\n\r\n* `Integer`, `Float`, `Character`, or `String`,\r\n* an enumerated type whose cases are all anonymous classes, such as `Boolean`,\r\n* a subtype of [[ceylon.language.meta.declaration::Declaration]]\r\n* an annotation class,\r\n* `{T*}` or `[T*]` where `T` is a legal annotation parameter type, or\r\n* any tuple type whose element types are legal annotation parameter types.\r\n\r\nAn initializer parameter of an annotation class may be variadic or defaulted.\r\n\r\n### Annotation constructors\r\n\r\nAn *annotation constructor* is simply a top level function, annotated with `annotation` whose return type is an\r\nannotation class type. For example:\r\n\r\n    \"An annotation constructor.\"\r\n    annotation Example example(String description=\"\") \r\n        => Example(description);\r\n\r\nEach parameter of an annotation constructor must have one of the following types:\r\n\r\n* `Integer`, `Float`, `Character`, or `String`,\r\n* an enumerated type whose cases are all anonymous classes, such as `Boolean`,\r\n* a subtype of [[ceylon.language.meta.declaration::Declaration]],\r\n* an annotation type,\r\n* `{T*}` or `[T*]` where `T` is a legal annotation constructor parameter type, or\r\n* any tuple type whose element types are legal annotation constructor parameter types.\r\n\r\nA parameter of an annotation constructor may be variadic or defaulted.\r\n\r\nThe constructor must simply instantiate and return the annotation class, and there are strict rules about the arguments\r\nto the instantiation.\r\n\r\nA given annotation class can have multiple annotation constructors.\r\n\"\"\"'}
                    RStar<CAnnotation>
                        CAnnotation
                            CLowerIdentifier{'see'}
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                        CSequencedArgumentList
                                            CInterfaceLiteral
                                                RLiteral{'interface'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'OptionalAnnotation'}
                                            CInterfaceLiteral
                                                RLiteral{'interface'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'SequencedAnnotation'}
                                            CFunctionLiteral
                                                CKwFunction{'function'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'annotations'}
                                            CFunctionLiteral
                                                CKwFunction{'function'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'optionalAnnotation'}
                                            CFunctionLiteral
                                                CKwFunction{'function'}
                                                CReferencePath
                                                    ROptional<CPackageQualifier>
                                                    CReferencePathElementList
                                                        CIdentifier{'sequencedAnnotations'}
                                    RLiteral{')'}
                        CAnnotation
                            CLowerIdentifier{'shared'}
                            ROptional<ICArguments>
                RLiteral{'interface'}
                CUpperIdentifier{'Annotation'}
                ROptional<CTypeParameters>
                ROptional<CCaseTypes>
                    CCaseTypes
                        RLiteral{'of'}
                        CCaseTypeList
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'ConstrainedAnnotation'}
                                    ROptional<CTypeArguments>
                                        CTypeArguments
                                            RLiteral{'<'}
                                            ROptional<CTypeArgumentList>
                                            RLiteral{'>'}
                ROptional<CSatisfiedTypes>
                ROptional<CTypeConstraints>
                CBlock
                    RLiteral{'{'}
                    CImports
                    CStatements
                    RLiteral{'}'}
    REof{'\r\n'}
