CXStart
    CCodeUnit
        CNamespace
            CAnnotations
                ROptional<ICStringLiteral>
                RStar<CAnnotation>
            RLiteral{'namespace'}
            CNamespacePath
                CIdentifier{'six'}
                CIdentifier{'core'}
            RLiteral{';'}
        CImports
        CTopDeclarations
            CInterfaceDeclaration
                CAnnotations
                    ROptional<ICStringLiteral>
                        CVerbatimString{'\"\"\"\r\nAbstract supertype of objects that contain other values, called *elements*, where it is possible to efficiently\r\ndetermine if a given value is an element. A `Category` may not be finite, and its elements may not even be countable.\r\nThus, unlike [[streams|Iterable]], the elements of a generic `Category` are not iterable.\r\n\r\n`Category` models a mathematical set, but is distinct from the [[Set]] collection type which represents finite sets.\r\n\r\nThe `in` operator may be used to determine if a value belongs to a `Category`:\r\n\r\n    if (69 in 0..100) { ... }\r\n    assert (key->item in { for (n in 0..100) n.string->n**2 });\r\n\r\nAn object may be a `Category` of two different disjoint element types. For example, [[String]] is a `Category` of its\r\n`Character`s and of its substrings.\r\n\r\n    if (\"hello\" in \"hello world\") { ... }\r\n    assert (\'.\' in string);\r\n\r\nEvery meaningful `Category` is formed from elements with some equivalence relation. Ordinarily, that equivalence\r\nrelation is [[value equality|Object.equals]]. Thus, ordinarily, `x==y` implies that `x in cat == y in cat`. But this\r\ncontract is not required since it is possible to form a meaningful `Category` using a different equivalence relation.\r\nFor example, an `IdentitySet` is a meaningful `Category`, where the equivalence relation is\r\n[[identity equality|Identifiable]].\r\n\r\nSince [[Null]] is not considered to have any meaningful equivalence relation, a `Category` may not contain the\r\n[[null value|null]].\r\n\r\nNote that even though `Category<Element>` is declared contravariant in its [[element type|Element]], most types that\r\ninherit `Category` are covariant in their element type, and therefore satisfy `Category<Object>`, resulting in some\r\nloss of typesafety. For such types, [[contains]] should return `false` for any value that is not an instance of the\r\nelement type. For example, `String` is a `Category<Object>`, not a `Category<Character|String>`, and `x in string`\r\nevaluates to `false` for every `x` that is not a `String` or `Character`.\r\n\"\"\"'}
                    RStar<CAnnotation>
                        CAnnotation
                            CLowerIdentifier{'by'}
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                        CSequencedArgumentList
                                            CLiteralString{'\"Gavin\"'}
                                    RLiteral{')'}
                        CAnnotation
                            CLowerIdentifier{'tagged'}
                            ROptional<ICArguments>
                                CPositionalArguments
                                    RLiteral{'('}
                                    ROptional<CSequencedArgumentList>
                                        CSequencedArgumentList
                                            CLiteralString{'\"Collections\"'}
                                    RLiteral{')'}
                        CAnnotation
                            CLowerIdentifier{'shared'}
                            ROptional<ICArguments>
                RLiteral{'interface'}
                CUpperIdentifier{'Category'}
                ROptional<CTypeParameters>
                    CTypeParameters
                        RLiteral{'<'}
                        CTypeParameterList
                            CTypeParameter
                                ROptional<ICVariance>
                                    CVariance{'in'}
                                CUpperIdentifier{'Element'}
                                ROptional<CTypeDefault>
                                    CTypeDefault
                                        RLiteral{'='}
                                        CTypePath
                                            CTypeReference
                                                CUpperIdentifier{'Object'}
                                                ROptional<CTypeArguments>
                        RLiteral{'>'}
                ROptional<CCaseTypes>
                ROptional<CSatisfiedTypes>
                ROptional<CTypeConstraints>
                    CTypeConstraints
                        CTypeConstraint
                            RLiteral{'given'}
                            ROptional<ICTypeName>
                                CUpperIdentifier{'Element'}
                            ROptional<CTypeParameters>
                            ROptional<CCaseTypes>
                            ROptional<CSatisfiedTypes>
                                CSatisfiedTypes
                                    RLiteral{'satisfies'}
                                    CUnionTypeList
                                        CTypePath
                                            CTypeReference
                                                CUpperIdentifier{'Object'}
                                                ROptional<CTypeArguments>
                CBlock
                    RLiteral{'{'}
                    CImports
                    CStatements
                        CTypedMethodDeclaration
                            CAnnotations
                                ROptional<ICStringLiteral>
                                    CVerbatimString{'\"\"\"\r\n    Returns `true` if the given value belongs to this `Category`, that is, if it is an element of this `Category`, or\r\n    `false` otherwise.\r\n    \r\n    For any instance `c` of `Category`, `c.contains(element)` may be written using the `in` operator:\r\n    \r\n        element in c\r\n    \r\n    For most `Category`s, the following relationship is  satisfied by every pair of elements `x` and `y`:\r\n    \r\n    - if `x == y`, then `x in category == y in category`\r\n    \r\n    However, it is possible to form a useful `Category` consistent with some other equivalence relation, for example `===`.\r\n    Therefore implementations of `contains()` which do not satisfy this relationship are tolerated.\r\n    \"\"\"'}
                                RStar<CAnnotation>
                                    CAnnotation
                                        CLowerIdentifier{'see'}
                                        ROptional<ICArguments>
                                            CPositionalArguments
                                                RLiteral{'('}
                                                ROptional<CSequencedArgumentList>
                                                    CSequencedArgumentList
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'containsEvery'}
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'containsAny'}
                                                RLiteral{')'}
                                    CAnnotation
                                        CLowerIdentifier{'shared'}
                                        ROptional<ICArguments>
                                    CAnnotation
                                        CLowerIdentifier{'formal'}
                                        ROptional<ICArguments>
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'Boolean'}
                                    ROptional<CTypeArguments>
                            CLowerIdentifier{'contains'}
                            ROptional<CTypeParameters>
                            RPlus<CParameters>
                                CParameters
                                    RLiteral{'('}
                                    ROptional<CParameterList>
                                        CParameterList
                                            CParameter
                                                CAnnotations
                                                    ROptional<ICStringLiteral>
                                                    RStar<CAnnotation>
                                                CTypedValueParameter
                                                    CTypePath
                                                        CTypeReference
                                                            CUpperIdentifier{'Element'}
                                                            ROptional<CTypeArguments>
                                                    CLowerIdentifier{'element'}
                                                    ROptional<CValueSpecifier>
                                    RLiteral{')'}
                            ROptional<CTypeConstraints>
                            COptionalFunctionSpecifier
                                ROptional<CFunctionSpecifier>
                                RLiteral{';'}
                        CTypedMethodDeclaration
                            CAnnotations
                                ROptional<ICStringLiteral>
                                    CVerbatimString{'\"\"\"\r\n    Returns `true` if every one of the given values belongs to this `Category`, or `false` otherwise.\r\n    \"\"\"'}
                                RStar<CAnnotation>
                                    CAnnotation
                                        CLowerIdentifier{'see'}
                                        ROptional<ICArguments>
                                            CPositionalArguments
                                                RLiteral{'('}
                                                ROptional<CSequencedArgumentList>
                                                    CSequencedArgumentList
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'contains'}
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'containsAny'}
                                                RLiteral{')'}
                                    CAnnotation
                                        CLowerIdentifier{'shared'}
                                        ROptional<ICArguments>
                                    CAnnotation
                                        CLowerIdentifier{'default'}
                                        ROptional<ICArguments>
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'Boolean'}
                                    ROptional<CTypeArguments>
                            CLowerIdentifier{'containsEvery'}
                            ROptional<CTypeParameters>
                            RPlus<CParameters>
                                CParameters
                                    RLiteral{'('}
                                    ROptional<CParameterList>
                                        CParameterList
                                            CParameter
                                                CAnnotations
                                                    ROptional<ICStringLiteral>
                                                    RStar<CAnnotation>
                                                CTypedValueParameter
                                                    CIterableType
                                                        RLiteral{'{'}
                                                        ROptional<ICVariadicType>
                                                            CVariadicTypeCore
                                                                CTypePath
                                                                    CTypeReference
                                                                        CUpperIdentifier{'Element'}
                                                                        ROptional<CTypeArguments>
                                                                CVariadicOperator{'*'}
                                                        RLiteral{'}'}
                                                    CLowerIdentifier{'elements'}
                                                    ROptional<CValueSpecifier>
                                    RLiteral{')'}
                            ROptional<CTypeConstraints>
                            CBlock
                                RLiteral{'{'}
                                CImports
                                CStatements
                                    CForElseStatement
                                        RLiteral{'for'}
                                        RLiteral{'('}
                                        ROptional<CForIterator>
                                            CForIterator
                                                CVariable
                                                    ROptional<ICVariableType>
                                                    CLowerIdentifier{'element'}
                                                    RStar<CParameters>
                                                CContainment
                                                    CContainmentOperator{'in'}
                                                    CMemberReference
                                                        CLowerIdentifier{'elements'}
                                                        ROptional<CTypeArguments>
                                        RLiteral{')'}
                                        CBlock
                                            RLiteral{'{'}
                                            CImports
                                            CStatements
                                                CIfElseStatement
                                                    RLiteral{'if'}
                                                    CConditions
                                                        RLiteral{'('}
                                                        ROptional<CConditionList>
                                                            CConditionList
                                                                CLogicalNegationExpr
                                                                    CNotOperator{'!'}
                                                                    CCallExpr
                                                                        CMemberReference
                                                                            CLowerIdentifier{'contains'}
                                                                            ROptional<CTypeArguments>
                                                                        CPositionalArguments
                                                                            RLiteral{'('}
                                                                            ROptional<CSequencedArgumentList>
                                                                                CSequencedArgumentList
                                                                                    CMemberReference
                                                                                        CLowerIdentifier{'element'}
                                                                                        ROptional<CTypeArguments>
                                                                            RLiteral{')'}
                                                        RLiteral{')'}
                                                    CBlock
                                                        RLiteral{'{'}
                                                        CImports
                                                        CStatements
                                                            CUnclosedStatement
                                                                CReturnStatement
                                                                    RLiteral{'return'}
                                                                    ROptional<ICExpression>
                                                                        CMemberReference
                                                                            CLowerIdentifier{'false'}
                                                                            ROptional<CTypeArguments>
                                                                RLiteral{';'}
                                                        RLiteral{'}'}
                                                    RStar<CElseIf>
                                                    ROptional<CElseBlock>
                                            RLiteral{'}'}
                                        ROptional<CElseBlock>
                                            CElseBlock
                                                RLiteral{'else'}
                                                CBlock
                                                    RLiteral{'{'}
                                                    CImports
                                                    CStatements
                                                        CUnclosedStatement
                                                            CReturnStatement
                                                                RLiteral{'return'}
                                                                ROptional<ICExpression>
                                                                    CMemberReference
                                                                        CLowerIdentifier{'true'}
                                                                        ROptional<CTypeArguments>
                                                            RLiteral{';'}
                                                    RLiteral{'}'}
                                RLiteral{'}'}
                        CTypedMethodDeclaration
                            CAnnotations
                                ROptional<ICStringLiteral>
                                    CVerbatimString{'\"\"\"\r\n    Returns `true` if any one of the given values belongs to this `Category`, or `false` otherwise.\r\n    \"\"\"'}
                                RStar<CAnnotation>
                                    CAnnotation
                                        CLowerIdentifier{'see'}
                                        ROptional<ICArguments>
                                            CPositionalArguments
                                                RLiteral{'('}
                                                ROptional<CSequencedArgumentList>
                                                    CSequencedArgumentList
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'contains'}
                                                        CFunctionLiteral
                                                            CKwFunction{'function'}
                                                            CReferencePath
                                                                ROptional<CPackageQualifier>
                                                                CReferencePathElementList
                                                                    CIdentifier{'containsEvery'}
                                                RLiteral{')'}
                                    CAnnotation
                                        CLowerIdentifier{'shared'}
                                        ROptional<ICArguments>
                                    CAnnotation
                                        CLowerIdentifier{'default'}
                                        ROptional<ICArguments>
                            CTypePath
                                CTypeReference
                                    CUpperIdentifier{'Boolean'}
                                    ROptional<CTypeArguments>
                            CLowerIdentifier{'containsAny'}
                            ROptional<CTypeParameters>
                            RPlus<CParameters>
                                CParameters
                                    RLiteral{'('}
                                    ROptional<CParameterList>
                                        CParameterList
                                            CParameter
                                                CAnnotations
                                                    ROptional<ICStringLiteral>
                                                    RStar<CAnnotation>
                                                CTypedValueParameter
                                                    CIterableType
                                                        RLiteral{'{'}
                                                        ROptional<ICVariadicType>
                                                            CVariadicTypeCore
                                                                CTypePath
                                                                    CTypeReference
                                                                        CUpperIdentifier{'Element'}
                                                                        ROptional<CTypeArguments>
                                                                CVariadicOperator{'*'}
                                                        RLiteral{'}'}
                                                    CLowerIdentifier{'elements'}
                                                    ROptional<CValueSpecifier>
                                    RLiteral{')'}
                            ROptional<CTypeConstraints>
                            CBlock
                                RLiteral{'{'}
                                CImports
                                CStatements
                                    CForElseStatement
                                        RLiteral{'for'}
                                        RLiteral{'('}
                                        ROptional<CForIterator>
                                            CForIterator
                                                CVariable
                                                    ROptional<ICVariableType>
                                                    CLowerIdentifier{'element'}
                                                    RStar<CParameters>
                                                CContainment
                                                    CContainmentOperator{'in'}
                                                    CMemberReference
                                                        CLowerIdentifier{'elements'}
                                                        ROptional<CTypeArguments>
                                        RLiteral{')'}
                                        CBlock
                                            RLiteral{'{'}
                                            CImports
                                            CStatements
                                                CIfElseStatement
                                                    RLiteral{'if'}
                                                    CConditions
                                                        RLiteral{'('}
                                                        ROptional<CConditionList>
                                                            CConditionList
                                                                CCallExpr
                                                                    CMemberReference
                                                                        CLowerIdentifier{'contains'}
                                                                        ROptional<CTypeArguments>
                                                                    CPositionalArguments
                                                                        RLiteral{'('}
                                                                        ROptional<CSequencedArgumentList>
                                                                            CSequencedArgumentList
                                                                                CMemberReference
                                                                                    CLowerIdentifier{'element'}
                                                                                    ROptional<CTypeArguments>
                                                                        RLiteral{')'}
                                                        RLiteral{')'}
                                                    CBlock
                                                        RLiteral{'{'}
                                                        CImports
                                                        CStatements
                                                            CUnclosedStatement
                                                                CReturnStatement
                                                                    RLiteral{'return'}
                                                                    ROptional<ICExpression>
                                                                        CMemberReference
                                                                            CLowerIdentifier{'true'}
                                                                            ROptional<CTypeArguments>
                                                                RLiteral{';'}
                                                        RLiteral{'}'}
                                                    RStar<CElseIf>
                                                    ROptional<CElseBlock>
                                            RLiteral{'}'}
                                        ROptional<CElseBlock>
                                            CElseBlock
                                                RLiteral{'else'}
                                                CBlock
                                                    RLiteral{'{'}
                                                    CImports
                                                    CStatements
                                                        CUnclosedStatement
                                                            CReturnStatement
                                                                RLiteral{'return'}
                                                                ROptional<ICExpression>
                                                                    CMemberReference
                                                                        CLowerIdentifier{'false'}
                                                                        ROptional<CTypeArguments>
                                                            RLiteral{';'}
                                                    RLiteral{'}'}
                                RLiteral{'}'}
                    RLiteral{'}'}
    REof{'\r\n'}
